<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Randomize Seconds & Calculate Duration</title>
    <script src="https://cdn.tailwindcss.com/3.4.3"></script>
    <style>
        /* Custom styles for centering and basic layout */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: "Inter", sans-serif; /* Using Inter font */
            padding: 1rem; /* Add some padding for smaller screens */
        }
        .container {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%; /* Make container responsive */
            max-width: 700px; /* Limit max width */
        }

        /* Styles for the data table appearance */
        .time-table {
            width: 100%;
            border-collapse: collapse; /* Remove space between borders */
            margin-bottom: 1.5rem;
            border: 1px solid #e5e7eb; /* Light gray border */
            border-radius: 0.25rem; /* Rounded corners */
            overflow: hidden; /* Hide overflow for rounded corners */
        }

        .time-table th, .time-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb; /* Border between rows */
        }

         .time-table th {
            background-color: #f9fafb; /* Light background for headers */
            font-weight: bold;
        }

        .time-table td {
            font-family: monospace; /* Monospace font for time display */
        }

        .time-table tbody tr:last-child td {
            border-bottom: none; /* No border for the last row */
        }

        .button {
            padding: 0.75rem 1.5rem;
            margin: 0.5rem;
            border-radius: 0.25rem; /* Rounded corners for buttons */
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        .button-primary {
            background-color: #3b82f6; /* Blue */
            color: white;
            border: none;
        }
        .button-primary:hover {
            background-color: #2563eb; /* Darker blue */
        }
        .button-secondary {
            background-color: #d1d5db; /* Gray */
            color: #1f2937; /* Dark gray text */
            border: none;
        }
        .button-secondary:hover {
            background-color: #9ca3af; /* Darker gray */
        }
         /* Message box for copy confirmation */
        .message-box {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 0.25rem;
            background-color: #d1fae5; /* Light green */
            color: #065f46; /* Dark green text */
            border: 1px solid #a7f3d0; /* Green border */
            visibility: hidden; /* Initially hidden */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .message-box.visible {
            visibility: visible;
            opacity: 1;
        }
         .message-box.error {
            background-color: #fee2e2; /* Light red for error */
            color: #991b1b; /* Dark red text */
            border-color: #fca5a5; /* Red border */
        }

         /* Responsive adjustments */
        @media (max-width: 480px) {
            .button {
                width: 100%;
                margin-left: 0;
                margin-right: 0;
            }
            .time-table th, .time-table td {
                padding: 0.5rem; /* Reduce padding on small screens */
            }
        }

        /* Basic Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center; /* Center horizontally (flex) */
            align-items: center; /* Center vertically (flex) */
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 600px;
            border-radius: 0.5rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative; /* For absolute positioning of close button */
        }

        .close-button {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
        }

        #timePointsEditor, #extraTaskEditor {
            max-height: 60vh; /* Limit height and allow scroll */
            overflow-y: auto;
            margin-bottom: 1rem; /* Space before buttons */
        }
        /* Style for invalid inputs in the modal */
        .input-error {
            border-color: red !important; /* Make sure it overrides tailwind */
        }
        /* Ensure extra task points take equal width within flex container */
        .extra-task-point {
            flex: 1 1 48%; /* Allows points to grow/shrink, taking roughly half width with a gap */
            min-width: 250px; /* Ensure they don't get too small before wrapping */
        }
    </style>
</head>
<body>

    <div class="container">
        <h2>Randomizer</h2>
        <p></p>

        <table class="time-table">
            <thead>
                <tr>
                    <th>Start Time</th>
                    <th>End Time</th>
                    <th>Duration</th>
                </tr>
            </thead>
            <tbody id="timeTableBody">
            </tbody>
        </table>

        <button id="randomizeButton" class="button button-primary">Randomize Seconds & Calculate</button>
        <button id="copyButton" class="button button-secondary">Copy Table Data</button>
        <button id="settingsButton" class="button button-secondary">Settings</button>
        <button id="addExtraTaskButton" class="button button-secondary">Add Extra Task</button>
        <button id="exportDataButton" class="button button-secondary">Export Data</button>
        <button id="importDataButton" class="button button-secondary">Import Data</button>
        <input type="file" id="importFileInput" accept=".json" style="display: none;">


        <div id="messageBox" class="message-box"></div>
    </div>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span id="closeSettingsModalButton" class="close-button">&times;</span>
            <h3 class="text-xl font-semibold mb-4">Edit Time Points (HH:MM AM/PM)</h3>
            <div id="timePointsEditor" class="mb-4">
            </div>
            <div class="text-right">
                <button id="saveSettingsButton" class="button button-primary mr-2">Save & Apply</button>
                <button id="cancelSettingsButton" class="button button-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="extraTaskModal" class="modal">
        <div class="modal-content">
            <span id="closeExtraTaskModalButton" class="close-button">&times;</span>
            <h3 class="text-xl font-semibold mb-4">Add Extra Task</h3>
            <div id="extraTaskEditor" class="mb-4 flex flex-wrap justify-center gap-4"> <div class="p-3 border border-gray-200 rounded-md shadow-sm extra-task-point"> <label class="block text-sm font-medium text-gray-700 mb-1">Point 1 (Start Time):</label>
                    <div class="flex items-center space-x-2">
                        <input type="number" min="1" max="12" value="12" id="extraTaskStartHour" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm w-20 text-center">
                        <span>H:</span>
                        <input type="number" min="0" max="59" value="00" id="extraTaskStartMinute" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm w-20 text-center">
                        <span>M:</span>
                        <select id="extraTaskStartPeriod" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            <option value="AM">AM</option>
                            <option value="PM">PM</option>
                        </select>
                    </div>
                </div>
                <div class="p-3 border border-gray-200 rounded-md shadow-sm extra-task-point"> <label class="block text-sm font-medium text-gray-700 mb-1">Point 2 (End Time):</label>
                    <div class="flex items-center space-x-2">
                        <input type="number" min="1" max="12" value="12" id="extraTaskEndHour" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm w-20 text-center">
                        <span>H:</span>
                        <input type="number" min="0" max="59" value="00" id="extraTaskEndMinute" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm w-20 text-center">
                        <span>M:</span>
                        <select id="extraTaskEndPeriod" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            <option value="AM">AM</option>
                            <option value="PM">PM</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="text-right">
                <button id="saveExtraTaskButton" class="button button-primary mr-2">Add Task</button>
                <button id="cancelExtraTaskButton" class="button button-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Get references to the elements
        const timeTableBody = document.getElementById('timeTableBody');
        const randomizeButton = document.getElementById('randomizeButton');
        const copyButton = document.getElementById('copyButton');
        const messageBox = document.getElementById('messageBox');
        
        // Elements for Settings Modal
        const settingsButton = document.getElementById('settingsButton');
        const settingsModal = document.getElementById('settingsModal');
        const timePointsEditor = document.getElementById('timePointsEditor');
        const saveSettingsButton = document.getElementById('saveSettingsButton');
        const cancelSettingsButton = document.getElementById('cancelSettingsButton');
        const closeSettingsModalButton = document.getElementById('closeSettingsModalButton');

        // Elements for Extra Task Modal
        const addExtraTaskButton = document.getElementById('addExtraTaskButton');
        const extraTaskModal = document.getElementById('extraTaskModal');
        const extraTaskStartHour = document.getElementById('extraTaskStartHour');
        const extraTaskStartMinute = document.getElementById('extraTaskStartMinute');
        const extraTaskStartPeriod = document.getElementById('extraTaskStartPeriod');
        const extraTaskEndHour = document.getElementById('extraTaskEndHour');
        const extraTaskEndMinute = document.getElementById('extraTaskEndMinute');
        const extraTaskEndPeriod = document.getElementById('extraTaskEndPeriod');
        const saveExtraTaskButton = document.getElementById('saveExtraTaskButton');
        const cancelExtraTaskButton = document.getElementById('cancelExtraTaskButton');
        const closeExtraTaskModalButton = document.getElementById('closeExtraTaskModalButton');

        // Elements for Export/Import
        const exportDataButton = document.getElementById('exportDataButton');
        const importDataButton = document.getElementById('importDataButton');
        const importFileInput = document.getElementById('importFileInput');


        // Keys for localStorage
        const LOCAL_STORAGE_KEY_TIME_POINTS = 'timeRandomizerSettings_userDefinedChronologicalTimePoints_v2_withAMPM';
        const LOCAL_STORAGE_KEY_EXTRA_TASKS = 'timeRandomizerExtraTasks_v1';

        // Updated originalData based on user's input
        const originalData = [
            { start: "13:45:02", end: "15:30:20", duration: "1:45:18" },
            { start: "13:30:01", end: "13:45:02", duration: "0:15:01" },
            { start: "12:00:15", end: "13:30:01", duration: "1:29:46" },
            { start: "11:00:26", end: "12:00:15", duration: "0:59:49" },
            { start: "08:45:55", end: "11:00:26", duration: "2:14:31" },
            { start: "08:30:11", end: "08:45:55", duration: "0:15:44" },
            { start: "06:30:36", end: "08:30:11", duration: "1:59:35" }
        ];

        let currentDisplayedData = []; // Array to hold the currently displayed data (mixed original randomized + extra tasks)
        // Stores { originalReferenceTime: string, currentHour: number, currentMinute: number, currentPeriod: 'AM' | 'PM', uniqueId: string }
        let userDefinedChronologicalTimePoints = []; 
        // Stores extra tasks { start: '12hr time', end: '12hr time', duration: 'HH:MM:SS', start24hr: '24hr time', end24hr: '24hr time' }
        let extraTaskSegments = []; 

        /**
         * Helper function to format time components (e.g., 5 -> "05").
         * @param {number} component - The hour, minute, or second.
         * @returns {string} The formatted component.
         */
        function formatTimeComponent(component) {
            // Ensure the component is treated as a number for the comparison
            const numComponent = parseInt(component, 10);
            return numComponent < 10 ? '0' + numComponent : String(numComponent);
        }

        /**
         * Generates a random second between 0 and 59.
         * @returns {number} A random second.
         */
        function generateRandomSecond() {
            return Math.floor(Math.random() * 60); // 0-59
        }

        /**
         * Converts a 24-hour time string (HH:MM:SS) to total seconds from midnight.
         * @param {string} timeString - The time string (e.g., "04:00:33").
         * @returns {number} Total seconds.
         */
        function timeToSeconds24Hr(timeString) {
            const parts = timeString.split(':');
            if (parts.length === 3) {
                const hours = parseInt(parts[0], 10) || 0;
                const minutes = parseInt(parts[1], 10) || 0;
                const seconds = parseInt(parts[2], 10) || 0;
                return (hours * 3600) + (minutes * 60) + seconds;
            }
            return 0;
        }

        /**
         * Converts total seconds from midnight to a 24-hour time string (HH:MM:SS).
         * @param {number} totalSeconds - Total seconds.
         * @returns {string} The formatted time string (e.g., "04:00:33").
         */
        function secondsToTime24Hr(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${formatTimeComponent(hours)}:${formatTimeComponent(minutes)}:${formatTimeComponent(seconds)}`;
        }

        /**
         * Converts a 12-hour time (hour and AM/PM) to a 24-hour hour.
         * @param {number} hour12 - Hour in 12-hour format (1-12).
         * @param {'AM'|'PM'} period - 'AM' or 'PM'.
         * @returns {number} Hour in 24-hour format (0-23).
         */
        function convert12hrTo24hr(hour12, period) {
            let hour24 = parseInt(hour12, 10);
            if (period === 'PM' && hour24 !== 12) {
                hour24 += 12;
            } else if (period === 'AM' && hour24 === 12) {
                hour24 = 0; // 12 AM is 00 in 24-hour format
            }
            return hour24;
        }

        /**
         * Converts a 24-hour time (hour and minute) to 12-hour format with AM/PM.
         * @param {number} hour24 - Hour in 24-hour format (0-23).
         * @param {number} minute - Minute.
         * @returns {{hour: number, minute: number, period: 'AM'|'PM'}} The 12-hour time object.
         */
        function convert24hrTo12hr(hour24, minute) {
            let hour12 = parseInt(hour24, 10);
            const period = hour12 >= 12 ? 'PM' : 'AM';

            if (hour12 === 0) {
                hour12 = 12; // 00:XX is 12 AM
            } else if (hour12 > 12) {
                hour12 -= 12; // 13:XX is 1 PM, etc.
            }
            return { hour: hour12, minute: minute, period: period };
        }

        /**
         * Calculates the duration between two 24-hour time strings, handling overnight times.
         * @param {string} startTime24Hr - Start time in HH:MM:SS (24hr).
         * @param {string} endTime24Hr - End time in HH:MM:SS (24hr).
         * @returns {string} Duration in HH:MM:SS.
         */
        function calculateDuration(startTime24Hr, endTime24Hr) {
            const startSeconds = timeToSeconds24Hr(startTime24Hr);
            const endSeconds = timeToSeconds24Hr(endTime24Hr);

            if (endSeconds >= startSeconds) {
                return secondsToTime24Hr(endSeconds - startSeconds);
            } else {
                const secondsInDay = 24 * 3600;
                return secondsToTime24Hr(secondsInDay - startSeconds + endSeconds);
            }
        }

        /**
         * Initializes user-defined time points from localStorage or originalData.
         */
        function initializeBaseTimePointsIfNeeded() {
            const N_segments = originalData.length;
            const expectedPointsCount = N_segments === 0 ? 0 : N_segments + 1;

            const storedSettingsString = localStorage.getItem(LOCAL_STORAGE_KEY_TIME_POINTS);
            if (storedSettingsString) {
                try {
                    const loadedPoints = JSON.parse(storedSettingsString);
                    if (Array.isArray(loadedPoints) && loadedPoints.length === expectedPointsCount) {
                        const isValidStructure = loadedPoints.every(p =>
                            typeof p.currentHour === 'number' &&
                            typeof p.currentMinute === 'number' &&
                            (p.currentPeriod === 'AM' || p.currentPeriod === 'PM') &&
                            typeof p.originalReferenceTime === 'string' &&
                            typeof p.uniqueId === 'string'
                        );

                        if (isValidStructure) {
                            userDefinedChronologicalTimePoints = loadedPoints;
                            console.log("Loaded time points from localStorage.");
                            return; 
                        } else {
                            console.warn("Stored settings have invalid structure. Re-initializing from originalData.");
                            localStorage.removeItem(LOCAL_STORAGE_KEY_TIME_POINTS);
                        }
                    } else {
                        console.warn("Stored settings count mismatch (likely due to originalData change). Re-initializing from originalData.");
                        localStorage.removeItem(LOCAL_STORAGE_KEY_TIME_POINTS);
                    }
                } catch (error) {
                    console.error("Error parsing stored settings. Re-initializing from originalData.", error);
                    localStorage.removeItem(LOCAL_STORAGE_KEY_TIME_POINTS);
                }
            }

            console.log("Initializing time points from originalData (24hr to 12hr conversion).");
            userDefinedChronologicalTimePoints = [];

            if (N_segments === 0) return;

            const tempChronologicalTimeStrings = [];
            // Assuming originalData is sorted chronologically *backwards* by end time
            // We need to extract all unique chronological time points.
            // A safer approach for initial points is to sort originalData by start time first,
            // then extract all unique start and end points and sort them.
            // For now, let's stick to the current logic which extracts from the given order.

            // This extraction assumes originalData is structured such that
            // originalData[N_segments - 1].start is the earliest point,
            // and then each subsequent originalData[i].end is chronologically later.
            tempChronologicalTimeStrings.push(originalData[N_segments - 1].start); // Earliest point
            for (let i = N_segments - 1; i >= 0; i--) {
                tempChronologicalTimeStrings.push(originalData[i].end); // Subsequent points
            }

            userDefinedChronologicalTimePoints = tempChronologicalTimeStrings.map((timeStr, index) => {
                const parts = timeStr.split(':');
                const hour24 = parseInt(parts[0], 10) || 0;
                const minute = parseInt(parts[1], 10) || 0;

                const converted = convert24hrTo12hr(hour24, minute);
                
                return {
                    originalReferenceTime: timeStr, 
                    currentHour: converted.hour,
                    currentMinute: converted.minute,
                    currentPeriod: converted.period,
                    uniqueId: `tp-${index}`
                };
            });
        }

        /**
         * Loads extra task segments from local storage.
         */
        function loadExtraTaskSegments() {
            const storedTasksString = localStorage.getItem(LOCAL_STORAGE_KEY_EXTRA_TASKS);
            if (storedTasksString) {
                try {
                    const loadedTasks = JSON.parse(storedTasksString);
                    if (Array.isArray(loadedTasks)) {
                        // Basic validation for extra task segments
                        const isValid = loadedTasks.every(task => 
                            typeof task.start === 'string' && 
                            typeof task.end === 'string' && 
                            typeof task.duration === 'string' && 
                            typeof task.start24hr === 'string' && 
                            typeof task.end24hr === 'string'
                        );
                        if (isValid) {
                            extraTaskSegments = loadedTasks;
                            console.log("Loaded extra tasks from localStorage.");
                        } else {
                            console.warn("Stored extra tasks have invalid structure. Resetting extra tasks.");
                            localStorage.removeItem(LOCAL_STORAGE_KEY_EXTRA_TASKS);
                            extraTaskSegments = [];
                        }
                    } else {
                        console.warn("Stored extra tasks is not an array. Resetting extra tasks.");
                        localStorage.removeItem(LOCAL_STORAGE_KEY_EXTRA_TASKS);
                        extraTaskSegments = [];
                    }
                } catch (error) {
                    console.error("Error parsing stored extra tasks. Resetting extra tasks.", error);
                    localStorage.removeItem(LOCAL_STORAGE_KEY_EXTRA_TASKS);
                    extraTaskSegments = [];
                }
            } else {
                extraTaskSegments = []; // Initialize if nothing in storage
            }
        }

        /**
         * Saves extra task segments to local storage.
         */
        function saveExtraTaskSegments() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY_EXTRA_TASKS, JSON.stringify(extraTaskSegments));
                console.log("Extra tasks saved to localStorage.");
            } catch (error) {
                console.error("Error saving extra tasks to localStorage:", error);
                showMessageBox('Failed to save extra tasks locally. Changes are not persisted.', true);
            }
        }


        /**
         * Generates randomized segments from user-defined time points,
         * combines them with extra tasks, sorts all segments, and updates the display.
         */
        function composeAndDisplayTable() {
            initializeBaseTimePointsIfNeeded();
            loadExtraTaskSegments(); // Load extra tasks

            const N_segments = originalData.length;
            let generatedSegments = [];

            if (N_segments === 0) {
                // If no original data, only display extra tasks
                generatedSegments = []; 
            } else {
                if (userDefinedChronologicalTimePoints.length !== N_segments + 1) {
                    console.error("Mismatch in time points count after initialization. This should not happen.");
                    showMessageBox("Error: Critical mismatch in time points. Please refresh.", true);
                    localStorage.removeItem(LOCAL_STORAGE_KEY_TIME_POINTS);
                    userDefinedChronologicalTimePoints = [];
                    initializeBaseTimePointsIfNeeded(); 
                    if (userDefinedChronologicalTimePoints.length !== N_segments + 1) {
                        showMessageBox("Error: Could not initialize time points correctly. Please check originalData.", true);
                        currentDisplayedData = extraTaskSegments; // Fallback to only extra tasks
                        updateDisplay();
                        hideMessageBox();
                        return;
                    }
                }
                
                const randomizedChronologicalPoints24Hr = userDefinedChronologicalTimePoints.map(tp => {
                    const randomSecond = generateRandomSecond();
                    const hour24 = convert12hrTo24hr(tp.currentHour, tp.currentPeriod);
                    return `${formatTimeComponent(hour24)}:${formatTimeComponent(tp.currentMinute)}:${formatTimeComponent(randomSecond)}`;
                });

                generatedSegments = originalData.map((originalEntry, k_original) => {
                    const startIndexInRandomizedPoints = (N_segments - 1) - k_original;
                    const endIndexInRandomizedPoints = N_segments - k_original;

                    const newStartTime24Hr = randomizedChronologicalPoints24Hr[startIndexInRandomizedPoints];
                    const newEndTime24Hr = randomizedChronologicalPoints24Hr[endIndexInRandomizedPoints];
                    const newDuration = calculateDuration(newStartTime24Hr, newEndTime24Hr);

                    // Convert 24hr times back to 12hr for display
                    const newStartTimeParts = newStartTime24Hr.split(':');
                    const newEndTimeParts = newEndTime24Hr.split(':');

                    const start12hr = convert24hrTo12hr(newStartTimeParts[0], newStartTimeParts[1]);
                    const end12hr = convert24hrTo12hr(newEndTimeParts[0], newEndTimeParts[1]);

                    // FIX: Ensure seconds are parsed as numbers before formatting
                    const displayStartTime = `${formatTimeComponent(start12hr.hour)}:${formatTimeComponent(start12hr.minute)}:${formatTimeComponent(parseInt(newStartTimeParts[2], 10))} ${start12hr.period}`;
                    const displayEndTime = `${formatTimeComponent(end12hr.hour)}:${formatTimeComponent(end12hr.minute)}:${formatTimeComponent(parseInt(newEndTimeParts[2], 10))} ${end12hr.period}`;

                    return {
                        start: displayStartTime,
                        end: displayEndTime,
                        duration: newDuration, 
                        start24hr: newStartTime24Hr,
                        end24hr: newEndTime24Hr
                    };
                });
            }

            // Combine generated segments with extra tasks
            currentDisplayedData = [...generatedSegments, ...extraTaskSegments];

            // Sort all segments by their 24hr start time
            currentDisplayedData.sort((a, b) => {
                return timeToSeconds24Hr(a.start24hr) - timeToSeconds24Hr(b.start24hr);
            });

            updateDisplay();
            hideMessageBox();
        }

        /**
         * Updates the HTML table with the currentDisplayedData.
         * @param {Array<Object>} segmentsToDisplay - The array of segments to display.
         */
        function updateDisplay() {
            timeTableBody.innerHTML = '';
            if (currentDisplayedData.length === 0) {
                 const row = document.createElement('tr');
                 const cell = document.createElement('td');
                 cell.colSpan = 3;
                 cell.textContent = "No tasks to display. Use 'Randomize' or 'Add Extra Task'.";
                 cell.className = 'text-center text-gray-500 py-4';
                 row.appendChild(cell);
                 timeTableBody.appendChild(row);
                 return;
            }
            currentDisplayedData.forEach(entry => {
                const row = document.createElement('tr');
                const startCell = document.createElement('td');
                startCell.textContent = entry.start;
                row.appendChild(startCell);
                const endCell = document.createElement('td');
                endCell.textContent = entry.end;
                row.appendChild(endCell);
                const durationCell = document.createElement('td');
                durationCell.textContent = entry.duration;
                row.appendChild(durationCell);
                timeTableBody.appendChild(row);
            });
        }

        /**
         * Copies the current table data to the clipboard in 24-hour format.
         */
        function copyTableDataToClipboard() {
            if (currentDisplayedData.length === 0) {
                showMessageBox('No data to copy.', true);
                return;
            }
            let textToCopy = "Start Time\tEnd Time\tDuration\n";
            currentDisplayedData.forEach(entry => {
                // Use the stored 24hr format for copying
                textToCopy += `${entry.start24hr}\t${entry.end24hr}\t${entry.duration}\n`;
            });
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => showMessageBox('Table data copied to clipboard!'))
                    .catch(err => {
                        console.error('Failed to copy text: ', err);
                        showMessageBox('Failed to copy table data.', true);
                    });
            } else {
                fallbackCopyTextToClipboard(textToCopy);
            }
        }

        /**
         * Fallback function for copying text to clipboard if navigator.clipboard is not available.
         * @param {string} text - The text to copy.
         */
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessageBox('Table data copied to clipboard (fallback)!');
                } else {
                    showMessageBox('Failed to copy table data (fallback).', true);
                }
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
                showMessageBox('Failed to copy table data (fallback).', true);
            }
            document.body.removeChild(textArea);
        }

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {boolean} [isError=false] - Whether the message is an error.
         */
        function showMessageBox(message, isError = false) {
            messageBox.textContent = message;
            messageBox.className = 'message-box visible';
            if (isError) {
                messageBox.classList.add('error');
            } else {
                messageBox.classList.remove('error');
            }
            setTimeout(hideMessageBox, 3000);
        }

        /**
         * Hides the message box.
         */
        function hideMessageBox() {
            messageBox.className = 'message-box';
            messageBox.classList.remove('error');
        }

        /**
         * Opens the settings modal and populates it with current time points.
         */
        function openSettingsModal() {
            initializeBaseTimePointsIfNeeded(); 
            timePointsEditor.innerHTML = '';

            if (userDefinedChronologicalTimePoints.length === 0 && originalData.length > 0) {
                 showMessageBox('Could not initialize time points for settings. Please refresh.', true);
                 return;
            }

            userDefinedChronologicalTimePoints.forEach((tp, index) => {
                const pointDiv = document.createElement('div');
                pointDiv.className = 'mb-4 p-3 border border-gray-200 rounded-md shadow-sm';

                const label = document.createElement('label');
                // Display the HH:MM part of the originalReferenceTime (24hr)
                const originalHHMM = tp.originalReferenceTime.substring(0, tp.originalReferenceTime.lastIndexOf(':'));
                label.textContent = `Point ${index + 1} (Original: ${originalHHMM} 24hr):`;
                label.className = 'block text-sm font-medium text-gray-700 mb-1';
                pointDiv.appendChild(label);

                const inputGroup = document.createElement('div');
                inputGroup.className = 'flex items-center space-x-2';

                const hourInput = document.createElement('input');
                hourInput.type = 'number';
                hourInput.min = '1'; 
                hourInput.max = '12'; 
                hourInput.value = tp.currentHour;
                hourInput.dataset.index = index;
                hourInput.dataset.type = 'hour';
                hourInput.className = 'hour-input p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm w-20 text-center';

                const minuteInput = document.createElement('input');
                minuteInput.type = 'number';
                minuteInput.min = '0';
                minuteInput.max = '59';
                minuteInput.value = formatTimeComponent(tp.currentMinute);
                minuteInput.dataset.index = index;
                minuteInput.dataset.type = 'minute';
                minuteInput.className = 'minute-input p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm w-20 text-center';
                
                const periodSelect = document.createElement('select');
                periodSelect.dataset.index = index;
                periodSelect.dataset.type = 'period';
                periodSelect.className = 'period-select p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm';

                const amOption = document.createElement('option');
                amOption.value = 'AM';
                amOption.textContent = 'AM';
                periodSelect.appendChild(amOption);

                const pmOption = document.createElement('option');
                pmOption.value = 'PM';
                pmOption.textContent = 'PM';
                periodSelect.appendChild(pmOption);

                periodSelect.value = tp.currentPeriod;

                inputGroup.appendChild(document.createTextNode('H: '));
                inputGroup.appendChild(hourInput);
                inputGroup.appendChild(document.createTextNode(' M: '));
                inputGroup.appendChild(minuteInput);
                inputGroup.appendChild(periodSelect);
                pointDiv.appendChild(inputGroup);

                timePointsEditor.appendChild(pointDiv);
            });
            settingsModal.style.display = 'flex';
        }

        /**
         * Saves settings from the modal to localStorage.
         */
        function saveSettings() {
            let allValid = true;
            const tempNewTimePointsSettings = JSON.parse(JSON.stringify(userDefinedChronologicalTimePoints));

            document.querySelectorAll('#timePointsEditor input').forEach(input => input.classList.remove('input-error'));
            document.querySelectorAll('#timePointsEditor select').forEach(select => select.classList.remove('input-error')); 

            tempNewTimePointsSettings.forEach((tp_settings, index) => {
                const hourInput = document.querySelector(`#timePointsEditor .hour-input[data-index="${index}"]`);
                const minuteInput = document.querySelector(`#timePointsEditor .minute-input[data-index="${index}"]`);
                const periodSelect = document.querySelector(`#timePointsEditor .period-select[data-index="${index}"]`);

                const newHour = parseInt(hourInput.value, 10);
                const newMinute = parseInt(minuteInput.value, 10);
                const newPeriod = periodSelect.value;

                if (isNaN(newHour) || newHour < 1 || newHour > 12) { 
                    allValid = false;
                    hourInput.classList.add('input-error');
                } else {
                    tp_settings.currentHour = newHour;
                }

                if (isNaN(newMinute) || newMinute < 0 || newMinute > 59) {
                    allValid = false;
                    minuteInput.classList.add('input-error');
                } else {
                    tp_settings.currentMinute = newMinute;
                }

                if (newPeriod !== 'AM' && newPeriod !== 'PM') {
                    allValid = false;
                    periodSelect.classList.add('input-error');
                } else {
                    tp_settings.currentPeriod = newPeriod;
                }
            });

            if (allValid) {
                userDefinedChronologicalTimePoints = tempNewTimePointsSettings; 

                try {
                    localStorage.setItem(LOCAL_STORAGE_KEY_TIME_POINTS, JSON.stringify(userDefinedChronologicalTimePoints));
                    console.log("Settings saved to localStorage.");
                } catch (error) {
                    console.error("Error saving settings to localStorage:", error);
                    showMessageBox('Failed to save settings locally. Changes are not persisted.', true);
                }

                settingsModal.style.display = 'none';
                composeAndDisplayTable(); 
                showMessageBox('Settings saved and times updated!');
            } else {
                showMessageBox('Invalid input. Hours must be 1-12, Minutes 0-59, and AM/PM selected.', true);
            }
        }

        /**
         * Cancels settings changes and closes the modal.
         */
        function cancelSettings() {
            document.querySelectorAll('#timePointsEditor input').forEach(input => input.classList.remove('input-error'));
            document.querySelectorAll('#timePointsEditor select').forEach(select => select.classList.remove('input-error'));
            settingsModal.style.display = 'none';
        }

        /**
         * Opens the extra task modal and resets its input fields.
         */
        function openExtraTaskModal() {
            extraTaskStartHour.value = '12';
            extraTaskStartMinute.value = '00';
            extraTaskStartPeriod.value = 'AM';
            extraTaskEndHour.value = '12';
            extraTaskEndMinute.value = '00';
            extraTaskEndPeriod.value = 'PM';

            // Clear any previous error highlighting
            extraTaskStartHour.classList.remove('input-error');
            extraTaskStartMinute.classList.remove('input-error');
            extraTaskStartPeriod.classList.remove('input-error');
            extraTaskEndHour.classList.remove('input-error');
            extraTaskEndMinute.classList.remove('input-error');
            extraTaskEndPeriod.classList.remove('input-error');

            extraTaskModal.style.display = 'flex';
        }

        /**
         * Saves a new extra task from the modal.
         */
        function saveExtraTask() {
            let allValid = true;

            const inputsToValidate = [
                { el: extraTaskStartHour, min: 1, max: 12, name: 'Start Hour' },
                { el: extraTaskStartMinute, min: 0, max: 59, name: 'Start Minute' },
                { el: extraTaskEndHour, min: 1, max: 12, name: 'End Hour' },
                { el: extraTaskEndMinute, min: 0, max: 59, name: 'End Minute' }
            ];

            // Clear previous errors
            inputsToValidate.forEach(item => item.el.classList.remove('input-error'));
            extraTaskStartPeriod.classList.remove('input-error');
            extraTaskEndPeriod.classList.remove('input-error');

            // Validate numeric inputs
            inputsToValidate.forEach(item => {
                const value = parseInt(item.el.value, 10);
                if (isNaN(value) || value < item.min || value > item.max) {
                    allValid = false;
                    item.el.classList.add('input-error');
                }
            });

            // Validate period selections
            if (extraTaskStartPeriod.value !== 'AM' && extraTaskStartPeriod.value !== 'PM') {
                allValid = false;
                extraTaskStartPeriod.classList.add('input-error');
            }
            if (extraTaskEndPeriod.value !== 'AM' && extraTaskEndPeriod.value !== 'PM') {
                allValid = false;
                extraTaskEndPeriod.classList.add('input-error');
            }

            if (!allValid) {
                showMessageBox('Invalid input for Extra Task. Please check all fields.', true);
                return;
            }

            // Convert to 24-hour format with random seconds for calculations
            const startHour24 = convert12hrTo24hr(extraTaskStartHour.value, extraTaskStartPeriod.value);
            const startMinute = parseInt(extraTaskStartMinute.value, 10);
            const startSecond = generateRandomSecond();
            const newStartTime24Hr = `${formatTimeComponent(startHour24)}:${formatTimeComponent(startMinute)}:${formatTimeComponent(startSecond)}`;

            const endHour24 = convert12hrTo24hr(extraTaskEndHour.value, extraTaskEndPeriod.value);
            const endMinute = parseInt(extraTaskEndMinute.value, 10);
            const endSecond = generateRandomSecond();
            const newEndTime24Hr = `${formatTimeComponent(endHour24)}:${formatTimeComponent(endMinute)}:${formatTimeComponent(endSecond)}`;

            // Calculate duration
            const newDuration = calculateDuration(newStartTime24Hr, newEndTime24Hr);

            // Convert 24hr times back to 12hr for display
            const start12hrDisplay = convert24hrTo12hr(startHour24, startMinute);
            const end12hrDisplay = convert24hrTo12hr(endHour24, endMinute);

            // FIX: Ensure seconds are treated as numbers here too for consistency, although formatTimeComponent now handles strings
            const displayStartTime = `${formatTimeComponent(start12hrDisplay.hour)}:${formatTimeComponent(start12hrDisplay.minute)}:${formatTimeComponent(startSecond)} ${start12hrDisplay.period}`;
            const displayEndTime = `${formatTimeComponent(end12hrDisplay.hour)}:${formatTimeComponent(end12hrDisplay.minute)}:${formatTimeComponent(endSecond)} ${end12hrDisplay.period}`;

            // Create new segment object
            const newExtraSegment = {
                start: displayStartTime,
                end: displayEndTime,
                duration: newDuration,
                start24hr: newStartTime24Hr,
                end24hr: newEndTime24Hr,
                isExtra: true // Flag to identify extra tasks if needed later
            };

            extraTaskSegments.push(newExtraSegment);
            saveExtraTaskSegments(); 
            extraTaskModal.style.display = 'none';
            composeAndDisplayTable(); 
            showMessageBox('Extra task added and table updated!');
        }

        /**
         * Cancels extra task addition and closes the modal.
         */
        function cancelExtraTask() {
            extraTaskStartHour.classList.remove('input-error');
            extraTaskStartMinute.classList.remove('input-error');
            extraTaskStartPeriod.classList.remove('input-error');
            extraTaskEndHour.classList.remove('input-error');
            extraTaskEndMinute.classList.remove('input-error');
            extraTaskEndPeriod.classList.remove('input-error');
            extraTaskModal.style.display = 'none';
        }

        /**
         * Exports the current time points and extra tasks as a JSON file.
         */
        function exportData() {
            const dataToExport = {
                randomizerPoints: userDefinedChronologicalTimePoints,
                extraTasks: extraTaskSegments
            };
            const jsonString = JSON.stringify(dataToExport, null, 2); // Pretty print JSON

            const filename = prompt("Enter filename for export:", "randomizer_data.json");
            if (!filename) {
                showMessageBox('Export cancelled.', true);
                return;
            }

            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox('Data exported successfully!');
        }

        /**
         * Imports data from a selected JSON file.
         */
        function importData() {
            importFileInput.click(); // Trigger the hidden file input click
        }

        /**
         * Handles the file selection for import.
         * @param {Event} event - The change event from the file input.
         */
        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                showMessageBox('No file selected.', true);
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Basic validation for imported data structure
                    if (importedData && typeof importedData === 'object' &&
                        Array.isArray(importedData.randomizerPoints) &&
                        Array.isArray(importedData.extraTasks)) {
                        
                        // Validate randomizerPoints structure (simplified)
                        const areRandomizerPointsValid = importedData.randomizerPoints.every(p => 
                            typeof p.currentHour === 'number' && typeof p.currentMinute === 'number' &&
                            (p.currentPeriod === 'AM' || p.currentPeriod === 'PM')
                        );

                        // Validate extraTasks structure (simplified)
                        const areExtraTasksValid = importedData.extraTasks.every(t => 
                            typeof t.start === 'string' && typeof t.end === 'string' &&
                            typeof t.start24hr === 'string' && typeof t.end24hr === 'string'
                        );

                        if (areRandomizerPointsValid && areExtraTasksValid) {
                            userDefinedChronologicalTimePoints = importedData.randomizerPoints;
                            extraTaskSegments = importedData.extraTasks;
                            
                            // Save imported data to local storage
                            localStorage.setItem(LOCAL_STORAGE_KEY_TIME_POINTS, JSON.stringify(userDefinedChronologicalTimePoints));
                            localStorage.setItem(LOCAL_STORAGE_KEY_EXTRA_TASKS, JSON.stringify(extraTaskSegments));

                            composeAndDisplayTable();
                            showMessageBox('Data imported successfully!');
                        } else {
                            showMessageBox('Invalid data structure in the imported file. Please ensure it matches the expected format.', true);
                        }
                    } else {
                        showMessageBox('Invalid file format. Please import a JSON file generated by this tool.', true);
                    }
                } catch (error) {
                    console.error("Error importing data:", error);
                    showMessageBox('Failed to import data. Please ensure it\'s a valid JSON file.', true);
                } finally {
                    // Reset the file input to allow selecting the same file again if needed
                    event.target.value = '';
                }
            };

            reader.onerror = () => {
                showMessageBox('Error reading file.', true);
                event.target.value = ''; // Reset file input
            };

            reader.readAsText(file);
        });


        // Add event listeners
        randomizeButton.addEventListener('click', composeAndDisplayTable); 
        copyButton.addEventListener('click', copyTableDataToClipboard);
        settingsButton.addEventListener('click', openSettingsModal);
        saveSettingsButton.addEventListener('click', saveSettings);
        cancelSettingsButton.addEventListener('click', cancelSettings);
        closeSettingsModalButton.addEventListener('click', cancelSettings);

        addExtraTaskButton.addEventListener('click', openExtraTaskModal);
        saveExtraTaskButton.addEventListener('click', saveExtraTask);
        cancelExtraTaskButton.addEventListener('click', cancelExtraTask);
        closeExtraTaskModalButton.addEventListener('click', cancelExtraTask);

        exportDataButton.addEventListener('click', exportData);
        importDataButton.addEventListener('click', importData);


        // Initial display when the page loads
        composeAndDisplayTable();
    </script>

</body>
</html>
