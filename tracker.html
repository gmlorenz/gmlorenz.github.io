<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team123 - Project Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f7f6; color: #333; line-height: 1.4; }
        .container { width: 98%; max-width: 1900px; margin: 10px auto; padding: 10px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 5px; }

        /* Styles for Auth Section - copied from tracker.html for direct control */
        #auth-container {
            /* Adjust these values */
            padding: 10px 15px; /* Reduced vertical and horizontal padding */
            min-height: 60px; /* Reduced minimum height */
            /* Keep these as they control layout */
            text-align: center;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #auth-container h2 {
            font-size: 1.1em; /* Slightly smaller heading */
            margin-bottom: 8px; /* Reduced space below heading */
            color: #333;
        }
        #user-info-display {
            /* Keep these as they control layout */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px; /* Slightly reduced gap */
            flex-wrap: wrap;
            margin-top: 5px; /* Reduced space above user info */
        }
        #user-info-display img {
            border-radius: 50%;
            width: 40px; /* Slightly smaller photo */
            height: 40px; /* Slightly smaller photo */
            border: 2px solid #ddd;
            object-fit: cover;
        }
        #user-info-display .user-details p {
            margin: 0;
            font-size: 0.9em; /* Slightly smaller font size */
        }
        #user-info-display .user-details p:first-child {
            font-weight: bold;
        }
        #signInBtn, #signOutBtn {
            padding: 8px 18px; /* Smaller buttons */
            font-size: 1em; /* Smaller font */
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            margin-top: 8px; /* Reduced space above button */
        }
        /* Keep hover styles as they are */
        #signInBtn { background-color: #4285F4; color: white; } #signInBtn:hover { background-color: #357ae8; }
        #signOutBtn { background-color: #e74c3c; color: white; } #signOutBtn:hover { background-color: #c0392b; }

        /* Initially hide app content and show loading/auth message */
        #app-content { display: none; }
        #loading-auth-message { text-align: center; padding: 20px; font-size: 1.1em; color: #555; margin-top: 50px;} /* Added margin-top to separate from auth-container */

        h1, h2, h3 { color: #2c3e50; text-align: center; margin-bottom: 12px; font-size: 1.5em; }
        h2 { font-size: 1.3em; }
        h3 { font-size: 1.1em; text-align: left; margin-top: 15px; border-bottom: 1px solid #ccc; padding-bottom: 5px;}
        .action-bar {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* Allows items to wrap to the next line */
            align-items: center; /* Vertically align items in the action bar */
            justify-content: flex-start; /* Align items to the start for better button grouping */
        }
        .btn { padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8em; transition: background-color 0.3s ease; margin: 2px; min-width: 60px; text-align: center; vertical-align: middle;}
        .btn-lg { padding: 7px 12px; font-size: 0.9em; }
        .btn-group-toggle { min-width: 25px; padding: 2px 6px; font-size: 0.9em; margin-left: 10px; background-color: #7f8c8d; color:white; }
        .btn-group-toggle:hover { background-color: #95a5a6;}
        .btn-danger { background-color: #e74c3c; color: white; } .btn-danger:hover { background-color: #c0392b; }
        .btn-primary { background-color: #3498db; color: white; } .btn-primary:hover { background-color: #2980b9; }
        .btn-success { background-color: #2ecc71; color: white; } .btn-success:hover { background-color: #27ae60; }
        .btn-mark-done { background-color: #1abc9c; color: white; } .btn-mark-done:hover { background-color: #16a085; }
        .btn-release { background-color: #9b59b6; color: white; font-size:0.85em; padding: 5px 10px; } .btn-release:hover { background-color: #8e44ad; }
        .btn-day-start { background-color: #007bff; color: white; }
        .btn-day-start:hover { background-color: #0056b3; }
        .btn-day-end { background-color: #fd7e14; color: white; }
        .btn-day-end:hover { background-color: #c85e08; }
        .btn-warning { background-color: #f39c12; color: white; }
        .btn-warning:hover { background-color: #e67e22; }
        .btn-info { background-color: #17a2b8; color: white; }
        .btn-info:hover { background-color: #138496; }
        .btn:disabled { background-color: #bdc3c7 !important; color: #7f8c8d !important; cursor: not-allowed; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 15px; border: 1px solid #888; width: 90%; border-radius: 5px; position: relative; }
        #projectFormModal .modal-content { max-width: 480px; }
        #tlDashboardModal .modal-content { max-width: 750px; max-height: 85vh; overflow-y: auto;}
        #settingsModal .modal-content { max-width: 550px; max-height: 85vh; overflow-y: auto;}
        #activityLogModal .modal-content { max-width: 700px; max-height: 85vh; overflow-y: auto;} /* NEW */
        .close-button { color: #aaa; float: right; font-size: 24px; font-weight: bold; } .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #newProjectForm label { display: block; margin-top: 8px; font-weight: bold; font-size: 0.85em;}
        #newProjectForm input[type="text"], #newProjectForm input[type="number"], #newProjectForm select { width: calc(100% - 18px); padding: 7px; margin-top: 3px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box; font-size: 0.85em; }
        #newProjectForm button[type="submit"] { margin-top: 12px; }
        #projectTable { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.8em; }
        #projectTable th, #projectTable td { border: 1px solid #ddd; padding: 3px 5px; text-align: left; vertical-align: middle; white-space: nowrap; }
        #projectTable thead th { background-color: #34495e; color: white; font-weight: bold; position: sticky; top: 0; z-index: 10;}
        #projectTable td.wrap-text { white-space: normal; }
        #projectTable select.assigned-to-select, /* Changed from input[type="text"].assigned-to-input */
        #projectTable textarea.tech-notes-input,
        #projectTable input[type="number"].additional-minutes-input {
            width: calc(100% - 6px); padding: 2px; border: 1px solid #ccc; border-radius: 2px; box-sizing: border-box; font-size: 1em; background-color: #fff;
        }
        #projectTable input[type="number"].additional-minutes-input { width: 60px; text-align: right;}
        #projectTable textarea.tech-notes-input { resize: vertical; min-height: 18px; line-height: 1.3; }
        .batch-header-row td { background-color: #6c757d !important; color: white; font-size: 1.1em; font-weight: bold; text-align: left; padding: 6px 8px; }
        .fix-group-header td { background-color: #adb5bd !important; color: #212529; font-size: 1.0em; font-weight: bold; text-align: left; padding: 4px 8px; cursor:pointer; padding-left: 30px; }
        .hidden-group-row { display: none; }
        .overall-project-separator td { height: 10px !important; background-color: #e9ecef !important; border: none !important; padding: 0 !important; }
        #projectTable td.total-duration-column { color: white; font-weight: bold; background-color: #e74c3c; }
        .fix1-row { background-color: #e6ffe6; }
        .fix2-row { background-color: #ffe6f2; }
        .fix3-row { background-color: #e6e6ff; }
        .fix4-row { background-color: #fff5e6; }
        /* NEW Fix Categories */
        .fix5-row { background-color: #e0f2f7; } /* Light Blue */
        .fix6-row { background-color: #ffe0b2; } /* Light Orange */

        .reassigned-task-highlight { background-color: #FFF9C4 !important; }
        #projectTable tbody tr:not(.fix-group-header):not(.batch-header-row):not(.overall-project-separator):hover { background-color: #d0e0f0 !important; }
        .status { padding: 2px 5px; border-radius: 3px; color: white; font-weight: bold; text-align: center; display: inline-block; font-size:0.95em; }
        .status-available { background-color: #3498db; }
        .status-inprogressday1 { background-color: #f39c12; }
        .status-day1ended_awaitingnext { background-color: #f39c12; }
        .status-inprogressday2 { background-color: #f39c12; }
        /* NEW STATUSES for Day3 */
        .status-day2ended_awaitingnext { background-color: #f39c12; } /* Same color as Day1Ended, for consistency */
        .status-inprogressday3 { background-color: #e9630e; } /* A slightly different orange for Day3 in progress */

        .status-completed { background-color: #2ecc71; }
        .status-reassigned_techabsent { background-color: #B0BEC5; color: #263238; }
        #tlDashboardContent { margin-top:15px; }
        .dashboard-batch-item { border: 1px solid #bdc3c7; padding: 10px; margin-bottom: 10px; background-color: #fff; border-radius: 4px; }
        .dashboard-batch-item h4 { margin-top: 0; margin-bottom: 8px; font-size: 1.05em; color: #34495e;}
        .dashboard-batch-item p { margin: 3px 0; font-size: 0.9em;}
        .dashboard-batch-actions-release { margin-top: 8px; margin-bottom: 8px; }
        .dashboard-batch-actions-delete { margin-top: 8px; border-top: 1px dashed #ccc; padding-top: 8px; display: flex; flex-wrap: wrap; gap: 5px;}
        .break-select {
            padding: 2px 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8em;
            min-width: 100px;
            margin-left: 5px;
        }
        #allowedEmailsList { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; margin-bottom: 10px;}
        #allowedEmailsList li { padding: 8px; border-bottom: 1px dashed #eee; display: flex; justify-content: space-between; align-items: center;}
        #allowedEmailsList li:last-child { border-bottom: none; }
        #allowedEmailsList li button { background-color: #dc3545; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-size: 0.8em;}
        #allowedEmailsList li button:hover { background-color: #c82333; }
        #addEmailInput { flex-grow: 1; padding: 7px; margin-right: 5px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box; font-size: 0.9em;}
        .settings-input-group { display: flex; margin-bottom: 10px; align-items: center;}
        #activityLogContent ul { list-style-type: disc; padding-left: 20px; margin-top: 10px;} /* NEW */
        #activityLogContent li { margin-bottom: 8px; border-bottom: 1px dotted #eee; padding-bottom: 5px;} /* NEW */
        #activityLogContent li:last-child { border-bottom: none;} /* NEW */

        /* NEW: Hide Additional(m) column */
        #projectTable th:nth-child(12), /* Assuming 12th column for Additional(m) */
        #projectTable td:nth-child(12) {
            display: none;
        }

        /* Styles for Pagination Controls */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
            gap: 10px;
        }
        .pagination-controls button {
            padding: 8px 15px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .pagination-controls button:hover:not(:disabled) {
            background-color: #e0e0e0;
        }
        .pagination-controls button:disabled {
            background-color: #ddd;
            color: #999;
            cursor: not-allowed;
        }
        .pagination-controls span {
            font-size: 0.9em;
            color: #555;
        }
        .pagination-controls select {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }

        /* Loading Overlay Styles */
        #loadingOverlay {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5); /* Black semi-transparent background */
            z-index: 9999; /* Sit on top */
            cursor: wait; /* Change cursor to indicate waiting */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            flex-direction: column; /* Stack text and spinner */
            color: white;
            font-size: 1.2em;
            font-weight: bold;
        }

        /* Spinner CSS (simplified) */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* TL Summary styles */
        #tlSummaryContent h3 {
            text-align: left;
            margin-top: 15px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #tlSummaryContent ul {
            list-style-type: none;
            padding: 0;
            margin-top: 10px;
        }
        #tlSummaryContent li {
            margin-bottom: 5px;
            padding: 5px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #tlSummaryContent li strong {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="auth-container">
            <h2></h2> <button id="signInBtn" class="btn btn-primary btn-lg">Sign in with Google</button>
            <div id="user-info-display" style="display: none;">
                <img id="userPhoto" src="" alt="User Photo">
                <div class="user-details">
                    <p id="userName"></p>
                    <p id="userEmail"></p>
                </div>
                <button id="signOutBtn" class="btn btn-danger">Sign Out</button>
            </div>
        </div>

        <div id="loading-auth-message">
            <p>Please sign in to access the Project Tracker.</p>
        </div>

        <div id="app-content">
            <h1></h1>
            <div class="action-bar">
                <button id="openAddNewProjectBtn" class="btn btn-success btn-lg">‚ûï Add New Tracker</button>
                <button id="openTlDashboardBtn" class="btn btn-primary btn-lg">üëë Project Settings</button>
                <button id="openSettingsBtn" class="btn btn-info btn-lg" style="display:none;">‚öôÔ∏è User Settings</button>
                <button id="openActivityLogBtn" class="btn btn-info btn-lg">üìä Activity Log</button>
            </div>

            <div id="projectFormModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeProjectFormBtn">&times;</span>
                    <h2>Add New Tracker</h2>
                    <form id="newProjectForm">
                        <label for="fixCategorySelect">Fix Category:</label>
                        <select id="fixCategorySelect" required>
                            <option value="Fix1">Fix1</option>
                            <option value="Fix2">Fix2</option>
                            <option value="Fix3">Fix3</option>
                            <option value="Fix4">Fix4</option>
                            <option value="Fix5">Fix5</option> <option value="Fix6">Fix6</option> </select>
                        <label for="numRows">Number of Area:</label>
                        <input type="number" id="numRows" value="1" min="1" required>
                        <label for="baseProjectName">Project Name:</label>
                        <input type="text" id="baseProjectName" value="PROJ_ID_XYZ" required>
                        <label for="gsd">GSD:</label>
                        <select id="gsd" required><option value="3in">3in</option><option value="9in">9in</option></select>
                        <button type="submit" class="btn btn-success">Add Project(s)</button>
                    </form>
                </div>
            </div>

            <div id="tlDashboardModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeTlDashboardBtn">&times;</span>
                    <h2>üëë Project Settings</h2>
                    <div id="tlSummaryContent"></div>
                    <hr>
                    <h3>Activity Log Management</h3>
                    <p>Old activity logs are automatically pruned. You can manually trigger a cleanup here if needed.</p>
                    <button id="cleanActivityLogsBtn" class="btn btn-danger">Clean Old Activity Logs</button>
                    <hr>
                    <div id="tlDashboardContent"></div>
                </div>
            </div>

            <div id="settingsModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeSettingsBtn">&times;</span>
                    <h2>‚öôÔ∏è User Settings</h2>
                    <h3>Manage Allowed User Emails</h3>
                    <ul id="allowedEmailsList">
                        </ul>
                    <div class="settings-input-group">
                        <input type="email" id="addEmailInput" placeholder="Enter new allowed email">
                        <button id="addEmailBtn" class="btn btn-success">Add Email</button>
                    </div>
                </div>
            </div>

            <div id="activityLogModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeActivityLogBtn">&times;</span>
                    <h2>üìä Activity Log</h2>
                    <div id="activityLogContent" style="max-height: 60vh; overflow-y: auto; font-size: 0.9em; padding: 10px; border: 1px solid #ddd; border-radius: 5px;"></div>
                </div>
            </div>
            <h3>üìå Team123 Project Tracker</h3>
            <div class="pagination-controls">
                <button id="prevPageBtn" disabled>Previous</button>
                <select id="pageSizeSelect">
                    <option value="10">10 per page</option>
                    <option value="25" selected>25 per page</option>
                    <option value="50">50 per page</option>
                    <option value="100">100 per page</option>
                </select>
                <button id="nextPageBtn">Next</button>
            </div>
            <table id="projectTable">
                <thead>
                    <tr>
                        <th>Fix</th><th style="min-width: 150px;">Project Name</th><th style="min-width: 80px;">Area</th><th>GSD</th>
                        <th style="min-width: 110px;">Assigned Tech</th><th style="min-width: 120px;">Status</th>
                        <th>D1 Start</th><th>D1 End</th>
                        <th>D2 Start</th><th>D2 End</th>
                        <th>D3 Start</th><th>D3 End</th> <th>Total(m)</th>
                        <th style="min-width: 120px;">Tech Notes</th><th style="min-width: 150px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="projectTableBody"></tbody>
            </table>
        </div>
    </div>

    <div id="loadingOverlay">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <script>
        // CRITICAL SECURITY WARNING: Your Firebase API keys are exposed here.
        // For production, secure your data with Firebase Security Rules and restrict API key usage in Google Cloud Console.
        const firebaseConfig = {
          apiKey: "AIzaSyADB1W9YKaU6DFqGyjivsADJOhuIRY0eZ0", // Replace with your actual key if different
          authDomain: "project-tracker-fddb1.firebaseapp.com",
          projectId: "project-tracker-fddb1",
          storageBucket: "project-tracker-fddb1.firebasestorage.app",
          messagingSenderId: "698282455986",
          appId: "1:698282455986:web:f31fa7830148dc47076aab",
          measurementId: "G-6D2Z9ZWEN1"
        };

        let app;
        let db;
        let auth;

        let signInBtn, signOutBtn, userInfoDisplayDiv, userNameP, userEmailP, userPhotoImg;
        let appContentDiv, loadingAuthMessageDiv;
        let loadingOverlay; // Reference to the loading overlay

        const TL_DASHBOARD_PIN = "1234";
        const ALLOWED_EMAILS_DOC_REF_PATH = "settings/allowedEmails";
        let allowedEmailsFromFirestore = [];

        // NEW: List of Tech IDs
        const TECH_IDS = [
            "4232JD", "7248AA", "4426KV", "4472JS", "7236LE",
            "4475JT", "7039NO", "7231NR", "7240HH", "7247JA",
            "7249SS", "7244AA", "7312VP"
        ];
        TECH_IDS.sort(); // Keep them sorted for the dropdown

        try {
            if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                throw new Error("Firebase SDK not loaded. Ensure Firebase scripts are correctly included.");
            }
            app = firebase.initializeApp(firebaseConfig);

            if (typeof app.firestore === 'undefined') {
                 throw new Error("Firestore SDK not loaded or initialized correctly with the app.");
            }
            db = firebase.firestore();

            if (typeof app.auth === 'undefined') {
                throw new Error("Firebase Auth SDK not loaded or initialized correctly with the app.");
            }
            auth = firebase.auth();

            console.log("Firebase initialized successfully (App, Firestore, Auth)!");
            fetchAllowedEmails();

        } catch (e) {
            console.error("CRITICAL: Error initializing Firebase: ", e.message);
            const loadingMsgDiv = document.getElementById('loading-auth-message');
            if (loadingMsgDiv) loadingMsgDiv.innerHTML = `<p style="color:red;">CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: ${e.message}</p>`;
            else alert("CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: " + e.message);
        }

        // UPDATED: Added Fix5 and Fix6
        const FIX_CATEGORIES_ORDER = ["Fix1", "Fix2", "Fix3", "Fix4", "Fix5", "Fix6"];
        // UPDATED: Added Day2Ended_AwaitingNext and InProgressDay3
        const STATUS_ORDER = {
            'Available': 1, 'InProgressDay1': 2, 'P_Day1Ended_AwaitingNext': 3, // Renamed for clarity, P_ indicates potential
            'InProgressDay2': 4, 'P_Day2Ended_AwaitingNext': 5, // Renamed
            'InProgressDay3': 6,
            'Completed': 7, 'Reassigned_TechAbsent': 8
        };
        // UPDATED: Changed from 16 to 15 columns (removing Additional(m))
        const NUM_TABLE_COLUMNS = 15;

        let openAddNewProjectBtn, openTlDashboardBtn, openSettingsBtn, projectFormModal, tlDashboardModal, settingsModal,
            closeProjectFormBtn, closeTlDashboardBtn, closeSettingsBtn, newProjectForm, projectTableBody,
            tlDashboardContentElement, allowedEmailsList, addEmailInput, addEmailBtn, cleanActivityLogsBtn;

        // NEW: Activity Log related variables
        let activityLogModal, closeActivityLogBtn, activityLogContentElement, openActivityLogBtn;

        // NEW: TL Summary related variable
        let tlSummaryContentElement;

        let projects = [];
        let groupVisibilityState = {};
        let isAppInitialized = false;
        let firestoreListenerUnsubscribe = null;

        // Pagination variables
        let pageSize = 25; // Default page size
        let lastVisibleDoc = null;
        let firstVisibleDoc = null;
        let queryHistory = []; // To store documents for going back
        let currentPage = 0;
        let prevPageBtn, nextPageBtn, pageSizeSelect;


        // --- Loading Overlay Functions ---
        function showLoading(message = "Loading...") {
            if (loadingOverlay) {
                loadingOverlay.querySelector('p').textContent = message;
                loadingOverlay.style.display = 'flex';
            }
        }

        function hideLoading() {
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }
        // --- End Loading Overlay Functions ---


        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }
        function formatMillisToMinutes(millis) { return (millis === null || typeof millis !== 'number' || millis < 0) ? 'N/A' : Math.floor(millis / 60000); }

        function calculateDurationMs(startTime, endTime) {
            let startMillis = startTime; let endMillis = endTime;
            if (startTime && typeof startTime.toMillis === 'function') startMillis = startTime.toMillis();
            if (endTime && typeof endTime.toMillis === 'function') endMillis = endTime.toMillis();
            else if (typeof startTime === 'number' && typeof endTime === 'number') { /* proceed */ }
            else if (startTime && typeof startTime.toMillis === 'function' && typeof endTime === 'number') { /* endMillis is already a number */ }
            else if (typeof startTime === 'number' && endTime && typeof endTime.toMillis === 'function') { /* startMillis is already a number */ }
            else {
                 if (!startTime || !endTime) return null;
                 if (typeof startTime !== 'number' && !isNaN(new Date(startTime).getTime())) startMillis = new Date(startTime).getTime();
                 if (typeof endTime !== 'number' && !isNaN(new Date(endTime).getTime())) endMillis = new Date(endTime).getTime();
            }
            return (!startMillis || !endMillis || endMillis < startMillis || isNaN(startMillis) || isNaN(endMillis)) ? null : endMillis - startMillis;
        }

        function loadGroupVisibilityState() {
            try { const savedState = localStorage.getItem('projectTrackerGroupVisibility'); if (savedState) groupVisibilityState = JSON.parse(savedState); else groupVisibilityState = {}; } catch (e) { console.error("Error parsing group visibility state from localStorage:", e); groupVisibilityState = {}; }
        }
        function saveGroupVisibilityState() {
            try { localStorage.setItem('projectTrackerGroupVisibility', JSON.stringify(groupVisibilityState)); } catch (lsError) { console.error("Error saving group visibility state to localStorage:", lsError); alert("Warning: Could not save your group visibility preferences.");}
        }

        async function fetchAllowedEmails() {
            showLoading("Fetching allowed emails..."); // Show loading
            if (!db) { console.error("Firestore (db) not initialized. Cannot fetch allowed emails."); hideLoading(); return; }
            try {
                const docRef = db.doc(ALLOWED_EMAILS_DOC_REF_PATH);
                const docSnap = await docRef.get();
                if (docSnap.exists) {
                    allowedEmailsFromFirestore = docSnap.data().emails || [];
                } else {
                    allowedEmailsFromFirestore = ["ev.lorens.ebrado@gmail.com"];
                }
            } catch (error) {
                console.error("Error fetching allowed emails:", error);
                allowedEmailsFromFirestore = ["ev.lorens.ebrado@gmail.com"];
            } finally {
                hideLoading(); // Hide loading
            }
        }

        async function updateAllowedEmailsInFirestore(newEmailsArray) {
            showLoading("Updating allowed emails..."); // Show loading
             if (!db) { alert("Database not initialized! Cannot update allowed emails."); hideLoading(); return false; }
            const docRef = db.doc(ALLOWED_EMAILS_DOC_REF_PATH);
            try {
                await docRef.set({ emails: newEmailsArray });
                allowedEmailsFromFirestore = newEmailsArray;
                return true;
            } catch (error) {
                console.error("Error updating allowed emails in Firestore:", error);
                alert("Error saving allowed emails. Error: " + error.message);
                return false;
            } finally {
                hideLoading(); // Hide loading
            }
        }

        // Modified: To include pagination logic
        async function initializeFirebaseAndLoadData(direction = 'next') {
            showLoading("Loading projects..."); // Show loading
            if (!db) { projects = []; refreshAllViews(); hideLoading(); return; }
            if (firestoreListenerUnsubscribe) firestoreListenerUnsubscribe(); // Unsubscribe from previous listener

            loadGroupVisibilityState();

            // The main change for efficient pagination: ordering by a single field
            let query = db.collection("projects").orderBy("creationTimestamp", "desc");

            if (direction === 'next' && lastVisibleDoc) {
                // For going to the next page, start fetching after the last document of the current page
                query = query.startAfter(lastVisibleDoc);
            } else if (direction === 'prev' && firstVisibleDoc) {
                 // For going to the previous page, end fetching before the first document of the current page
                 // This works because the query is ordered descending, so 'endBefore' effectively goes back
                 query = query.endBefore(firstVisibleDoc);
            }

            try {
                firestoreListenerUnsubscribe = query.limit(pageSize).onSnapshot((querySnapshot) => { // Limit the number of documents per fetch
                    const firebaseProjects = [];
                    querySnapshot.forEach((doc) => {
                        if (doc.exists && typeof doc.data === 'function') {
                            firebaseProjects.push({ id: doc.id, ...doc.data() });
                        }
                    });

                    if (firebaseProjects.length === 0 && currentPage > 0 && direction === 'next') {
                        // Reached end of data, go back to previous page
                        currentPage--;
                        lastVisibleDoc = queryHistory[currentPage] ? queryHistory[currentPage].lastVisible : null;
                        firstVisibleDoc = queryHistory[currentPage] ? queryHistory[currentPage].firstVisible : null;
                        initializeFirebaseAndLoadData('prev'); // Try to go back to the previous known page
                        return;
                    }
                     if (firebaseProjects.length === 0 && currentPage === 0 && direction === 'prev') {
                        // Already at the beginning and no data, stay put.
                        lastVisibleDoc = null;
                        firstVisibleDoc = null;
                        projects = [];
                        updatePaginationButtons(false, false);
                        refreshAllViews();
                        hideLoading(); // Hide loading even if no data
                        return;
                    }


                    projects = firebaseProjects;

                    // Update lastVisibleDoc and firstVisibleDoc for pagination
                    lastVisibleDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
                    firstVisibleDoc = querySnapshot.docs[0];

                    if (direction === 'next' && querySnapshot.docs.length > 0) { // Only push if there are documents fetched
                        // Store the current page's markers
                        if (queryHistory.length <= currentPage) { // Prevent duplicates if re-rendering current page
                            queryHistory.push({ firstVisible: firstVisibleDoc, lastVisible: lastVisibleDoc });
                        } else { // Update if on the current page
                            queryHistory[currentPage] = { firstVisible: firstVisibleDoc, lastVisible: lastVisibleDoc };
                        }
                        // currentPage is incremented after push to point to the next expected page's index
                        if (direction === 'next' && queryHistory.length > currentPage + 1) { // Only increment if not the last item
                             currentPage++;
                        } else if (direction === 'next' && querySnapshot.docs.length === pageSize) { // Only increment if a full page was fetched
                             currentPage++;
                        }

                    } else if (direction === 'prev' && querySnapshot.docs.length > 0) { // Only adjust if documents fetched
                        // currentPage is decremented before fetch
                        if (currentPage > 0) {
                            currentPage--;
                        }
                    } else if (direction === 'prev' && querySnapshot.docs.length === 0 && currentPage === 0){
                        // This case handles being at the start and trying to go back further, result in no data
                        projects = [];
                        currentPage = 0;
                        firstVisibleDoc = null;
                        lastVisibleDoc = null;
                        queryHistory = [];
                    }

                    updatePaginationButtons(querySnapshot.docs.length < pageSize, currentPage === 0);
                    refreshAllViews();
                }, (error) => {
                    console.error("Error fetching projects: ", error);
                    projects = [];
                    updatePaginationButtons(true, true); // Disable both on error
                    refreshAllViews();
                });
            } catch (fbError) {
                console.error("Error setting up Firebase listener: ", fbError);
            } finally {
                hideLoading(); // Hide loading
            }
        }

        function updatePaginationButtons(isLastPage, isFirstPage) {
            if (prevPageBtn) prevPageBtn.disabled = isFirstPage;
            if (nextPageBtn) nextPageBtn.disabled = isLastPage;
        }

        function setupDOMReferences() {
            openAddNewProjectBtn = document.getElementById('openAddNewProjectBtn');
            openTlDashboardBtn = document.getElementById('openTlDashboardBtn');
            openSettingsBtn = document.getElementById('openSettingsBtn');
            projectFormModal = document.getElementById('projectFormModal');
            tlDashboardModal = document.getElementById('tlDashboardModal');
            settingsModal = document.getElementById('settingsModal');
            closeProjectFormBtn = document.getElementById('closeProjectFormBtn');
            closeTlDashboardBtn = document.getElementById('closeTlDashboardBtn');
            closeSettingsBtn = document.getElementById('closeSettingsBtn');
            newProjectForm = document.getElementById('newProjectForm');
            projectTableBody = document.getElementById('projectTableBody');
            tlDashboardContentElement = document.getElementById('tlDashboardContent');
            allowedEmailsList = document.getElementById('allowedEmailsList');
            addEmailInput = document.getElementById('addEmailInput');
            addEmailBtn = document.getElementById('addEmailBtn');
            cleanActivityLogsBtn = document.getElementById('cleanActivityLogsBtn');

            // NEW: Activity Log references
            openActivityLogBtn = document.getElementById('openActivityLogBtn');
            activityLogModal = document.getElementById('activityLogModal');
            closeActivityLogBtn = document.getElementById('closeActivityLogBtn');
            activityLogContentElement = document.getElementById('activityLogContent');

            // NEW: TL Summary reference
            tlSummaryContentElement = document.getElementById('tlSummaryContent');

            // Pagination references
            prevPageBtn = document.getElementById('prevPageBtn');
            nextPageBtn = document.getElementById('nextPageBtn');
            pageSizeSelect = document.getElementById('pageSizeSelect');

            loadingOverlay = document.getElementById('loadingOverlay'); // Get reference to loading overlay
        }

        function setupAuthRelatedDOMReferences() {
            signInBtn = document.getElementById('signInBtn');
            signOutBtn = document.getElementById('signOutBtn');
            userInfoDisplayDiv = document.getElementById('user-info-display');
            userNameP = document.getElementById('userName');
            userEmailP = document.getElementById('userEmail');
            userPhotoImg = document.getElementById('userPhoto');
            appContentDiv = document.getElementById('app-content');
            loadingAuthMessageDiv = document.getElementById('loading-auth-message');
            // openSettingsBtn is already set up in setupDOMReferences, but it's okay to re-set here if needed.
        }

        function attachEventListeners() {
            if (openAddNewProjectBtn) openAddNewProjectBtn.onclick = () => { projectFormModal.style.display = 'block'; };
            if (closeProjectFormBtn) closeProjectFormBtn.onclick = () => { projectFormModal.style.display = 'none'; };
            if (openTlDashboardBtn) {
                openTlDashboardBtn.onclick = () => {
                    const pin = prompt("Enter PIN to access Project Settings:");
                    if (pin === TL_DASHBOARD_PIN) {
                        tlDashboardModal.style.display = 'block';
                        renderTLSummary(); // Render TL Summary
                        renderTLDashboard(); // Render Project Settings
                    } else { alert("Incorrect PIN."); }
                };
            }
            if (closeTlDashboardBtn) closeTlDashboardBtn.onclick = () => { tlDashboardModal.style.display = 'none'; };
            if (openSettingsBtn) openSettingsBtn.onclick = () => { settingsModal.style.display = 'block'; renderAllowedEmailsList(); };
            if (closeSettingsBtn) closeSettingsBtn.onclick = () => { settingsModal.style.display = 'none'; };
            if (addEmailBtn) addEmailBtn.onclick = handleAddEmail;
            if (cleanActivityLogsBtn) cleanActivityLogsBtn.onclick = handleCleanActivityLogs;

            // NEW: Activity Log button and close event listener
            if (openActivityLogBtn) openActivityLogBtn.onclick = () => {
                activityLogModal.style.display = 'block'; renderActivityLog();
            };
            if (closeActivityLogBtn) closeActivityLogBtn.onclick = () => { activityLogModal.style.display = 'none'; };

            // Pagination event listeners
            if (prevPageBtn) prevPageBtn.onclick = () => {
                 lastVisibleDoc = queryHistory[currentPage - 1]?.lastVisible || null;
                 firstVisibleDoc = queryHistory[currentPage - 1]?.firstVisible || null;
                 initializeFirebaseAndLoadData('prev');
            };
            if (nextPageBtn) nextPageBtn.onclick = () => {
                initializeFirebaseAndLoadData('next');
            };
            if (pageSizeSelect) pageSizeSelect.onchange = (event) => {
                pageSize = parseInt(event.target.value, 10);
                lastVisibleDoc = null; // Reset pagination
                firstVisibleDoc = null;
                queryHistory = [];
                currentPage = 0;
                initializeFirebaseAndLoadData();
            };

            if (typeof window !== 'undefined') {
                window.onclick = (event) => {
                    if (event.target == projectFormModal) projectFormModal.style.display = 'none';
                    if (event.target == tlDashboardModal) tlDashboardModal.style.display = 'none';
                    if (event.target == settingsModal) settingsModal.style.display = 'none';
                    if (event.target == activityLogModal) activityLogModal.style.display = 'none';
                };
            }
            if (newProjectForm) newProjectForm.addEventListener('submit', handleAddProjectSubmit);
            setupAuthEventListeners();
        }

        // NEW: Function to log activities
        async function logActivity(action, details = {}) {
            if (!db || !auth.currentUser) {
                console.warn("Firestore or authenticated user not available for logging activity.");
                return;
            }
            try {
                await db.collection("activity_logs").add({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    userId: auth.currentUser.uid,
                    userEmail: auth.currentUser.email,
                    action: action,
                    details: details
                });
                console.log("Activity logged:", action, details);
            } catch (error) {
                console.error("Error logging activity:", error);
            }
        }

        // NEW: Function to fetch and render the activity log
        async function renderActivityLog() {
            showLoading("Loading activity log..."); // Show loading
            if (!activityLogContentElement) {
                console.error("activityLogContentElement not found.");
                hideLoading();
                return;
            }
            activityLogContentElement.innerHTML = '<p>Loading activity log...</p>';

            try {
                // Fetch latest 50 logs
                const querySnapshot = await db.collection("activity_logs").orderBy("timestamp", "desc").limit(50).get();
                if (querySnapshot.empty) {
                    activityLogContentElement.innerHTML = '<p>No activities recorded yet.</p>';
                    return;
                }

                let logHtml = '<ul style="list-style: none; padding: 0;">';
                querySnapshot.forEach(doc => {
                    const log = doc.data();
                    const date = log.timestamp ? new Date(log.timestamp.toDate()).toLocaleString() : 'N/A';
                    let detailsHtml = '';
                    if (log.details && Object.keys(log.details).length > 0) {
                        detailsHtml += '<ul style="list-style-type: disc; margin-top: 5px; padding-left: 20px; font-size: 0.9em;">';
                        for (const key in log.details) {
                            if (log.details.hasOwnProperty(key)) {
                                detailsHtml += `<li><strong>${key}:</strong> ${JSON.stringify(log.details[key]).replace(/"/g, '')}</li>`;
                            }
                            }
                        detailsHtml += '</ul>';
                    }
                    logHtml += `
                        <li style="margin-bottom: 10px; border-bottom: 1px dotted #eee; padding-bottom: 8px;">
                            <strong>${date}</strong> -
                            <span style="font-weight: bold; color: #555;">${log.userEmail || 'Unknown User'}</span>:
                            ${log.action}
                            ${detailsHtml}
                        </li>
                    `;
                });
                logHtml += '</ul>';
                activityLogContentElement.innerHTML = logHtml;

            } catch (error) {
                console.error("Error fetching activity logs:", error);
                activityLogContentElement.innerHTML = '<p style="color:red;">Error loading activity log.</p>';
            } finally {
                hideLoading(); // Hide loading
            }
        }

        async function handleCleanActivityLogs() {
            if (!confirm("Are you sure you want to delete all activity logs older than the latest 50? This action is irreversible.")) {
                return;
            }
            showLoading("Cleaning activity logs..."); // Show loading

            if (!db) {
                alert("Database not initialized! Cannot clean logs.");
                hideLoading();
                return;
            }

            try {
                const latestLogsSnapshot = await db.collection("activity_logs")
                    .orderBy("timestamp", "desc")
                    .limit(50)
                    .get();

                if (latestLogsSnapshot.empty) {
                    alert("No activity logs to clean.");
                    return;
                }

                let oldestTimestampToKeep = null;
                if (latestLogsSnapshot.docs.length === 50) {
                    oldestTimestampToKeep = latestLogsSnapshot.docs[latestLogsSnapshot.docs.length - 1].data().timestamp;
                } else {
                    alert("Fewer than 50 logs found, no logs to delete.");
                    return;
                }

                if (!oldestTimestampToKeep) {
                    alert("Could not determine oldest timestamp to keep.");
                    return;
                }

                const oldLogsSnapshot = await db.collection("activity_logs")
                    .where("timestamp", "<", oldestTimestampToKeep)
                    .get();

                if (oldLogsSnapshot.empty) {
                    alert("No old activity logs to delete.");
                    return;
                }

                const batch = db.batch();
                let deletedCount = 0;
                oldLogsSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                    deletedCount++;
                });

                await batch.commit();
                alert(`Successfully deleted ${deletedCount} old activity logs.`);
                logActivity('Cleaned Old Activity Logs', { deletedCount: deletedCount, oldestTimestampKept: oldestTimestampToKeep.toDate().toLocaleString() });
                renderActivityLog();
            } catch (error) {
                console.error("Error cleaning activity logs:", error);
                alert("Error cleaning activity logs: " + error.message);
            } finally {
                hideLoading(); // Hide loading
            }
        }

        // NEW: Function to render the TL Summary
        function renderTLSummary() {
            showLoading("Calculating TL Summary..."); // Show loading
            if (!tlSummaryContentElement) {
                console.error("tlSummaryContentElement not found.");
                hideLoading();
                return;
            }
            tlSummaryContentElement.innerHTML = ''; // Clear previous content

            const summaryByProjectAndFix = {};

            projects.forEach(project => {
                if (project && project.baseProjectName && project.fixCategory) {
                    const key = `${project.baseProjectName}_${project.fixCategory}`;
                    if (!summaryByProjectAndFix[key]) {
                        summaryByProjectAndFix[key] = {
                            baseProjectName: project.baseProjectName,
                            fixCategory: project.fixCategory,
                            totalDurationMs: 0
                        };
                    }

                    let totalRawDurationMs = (project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) + (project.durationDay3Ms || 0);
                    let breakToSubtractMs = (project.breakDurationMinutes || 0) * 60000;
                    let additionalManualMs = (project.additionalMinutesManual || 0) * 60000;
                    let durationAfterBreakMs = Math.max(0, totalRawDurationMs - breakToSubtractMs);
                    let finalTotalDurationMs = durationAfterBreakMs + additionalManualMs;

                    if (finalTotalDurationMs !== null) {
                        summaryByProjectAndFix[key].totalDurationMs += finalTotalDurationMs;
                    }
                }
            });

            let summaryHtml = '<h3>TL Summary (Per Project, Per Fix Category)</h3>';
            summaryHtml += '<ul>';

            const sortedKeys = Object.keys(summaryByProjectAndFix).sort((a, b) => {
                const projectA = summaryByProjectAndFix[a].baseProjectName;
                const projectB = summaryByProjectAndFix[b].baseProjectName;
                if (projectA < projectB) return -1;
                if (projectA > projectB) return 1;

                const fixOrderA = FIX_CATEGORIES_ORDER.indexOf(summaryByProjectAndFix[a].fixCategory);
                const fixOrderB = FIX_CATEGORIES_ORDER.indexOf(summaryByProjectAndFix[b].fixCategory);
                return fixOrderA - fixOrderB;
            });

            sortedKeys.forEach(key => {
                const summary = summaryByProjectAndFix[key];
                const totalMinutes = Math.floor(summary.totalDurationMs / 60000);
                const decimalHours = (summary.totalDurationMs / 3600000).toFixed(2); // Convert milliseconds to hours and format to 2 decimal places

                summaryHtml += `
                    <li>
                        <strong>Project Name:</strong> ${summary.baseProjectName} (${summary.fixCategory})<br>
                        <strong>Total:</strong> ${totalMinutes} minutes<br>
                        <strong>Decimal:</strong> ${decimalHours} hours
                    </li>
                `;
            });
            summaryHtml += '</ul>';
            tlSummaryContentElement.innerHTML = summaryHtml;
            hideLoading(); // Hide loading
        }


        async function handleAddProjectSubmit(e) {
            e.preventDefault();
            showLoading("Adding project(s)..."); // Show loading
            if (!db) { alert("Database not initialized!"); hideLoading(); return; }
            const fixCategory = document.getElementById('fixCategorySelect').value;
            const numRows = parseInt(document.getElementById('numRows').value, 10);
            const baseProjectNameVal = document.getElementById('baseProjectName').value.trim();
            const gsd = document.getElementById('gsd').value;

            if (!baseProjectNameVal || isNaN(numRows) || numRows < 1) { alert("Invalid input."); hideLoading(); return; }

            const currentBatchId = "batch_" + generateId();
            const batchCreationTimestamp = firebase.firestore.FieldValue.serverTimestamp();
            const fbBatch = db.batch();

            try {
                for (let i = 1; i <= numRows; i++) {
                    const newProjectData = {
                        batchId: currentBatchId, creationTimestamp: batchCreationTimestamp, fixCategory: fixCategory,
                        baseProjectName: baseProjectNameVal, areaTask: `Area${String(i).padStart(2, '0')}`, gsd: gsd,
                        assignedTo: "", techNotes: "", status: 'Available',
                        startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null,
                        startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                        startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null,
                        releasedToNextStage: false, lastModifiedTimestamp: batchCreationTimestamp,
                        isReassigned: false, originalProjectId: null,
                        breakDurationMinutes: 0,
                        additionalMinutesManual: 0
                    };
                    fbBatch.set(db.collection("projects").doc(), newProjectData);
                }
                await fbBatch.commit();
                logActivity('Added New Project(s)', {
                    fixCategory: fixCategory,
                    numRows: numRows,
                    baseProjectName: baseProjectNameVal,
                    gsd: gsd,
                    batchId: currentBatchId.split('_')[1]
                });
                newProjectForm.reset();
            } catch (error) { console.error("Error adding projects: ", error); alert("Error: " + error.message); }
            finally { projectFormModal.style.display = 'none'; hideLoading(); }
        }

        function getManageableBatches() {
            const allBatchesInfo = {};
            projects.forEach(p => {
                if (p && p.batchId) {
                    if (!allBatchesInfo[p.batchId]) allBatchesInfo[p.batchId] = { batchId: p.batchId, baseProjectName: p.baseProjectName || "N/A", tasksByFix: {} };
                    if (p.fixCategory && !allBatchesInfo[p.batchId].tasksByFix[p.fixCategory]) allBatchesInfo[p.batchId].tasksByFix[p.fixCategory] = [];
                    if (p.fixCategory) allBatchesInfo[p.batchId].tasksByFix[p.fixCategory].push(p);
                }
            });
            return Object.values(allBatchesInfo);
        }

        function renderTLDashboard() {
            showLoading("Loading Project Settings..."); // Show loading
            if (!tlDashboardContentElement) { console.error("tlDashboardContentElement not found."); hideLoading(); return; }
            tlDashboardContentElement.innerHTML = '';
            const manageableBatches = getManageableBatches();
            if (manageableBatches.length === 0) { tlDashboardContentElement.innerHTML = '<p>No project batches found in current view. (Consider loading all projects for full management)</p>'; hideLoading(); return; }

            manageableBatches.forEach(batch => {
                if (!batch || !batch.batchId) return;
                const batchDiv = document.createElement('div');
                batchDiv.classList.add('dashboard-batch-item');
                const title = document.createElement('h4');
                title.textContent = `Batch: ${batch.baseProjectName || 'Unknown'} (ID: ${batch.batchId.split('_')[1] || 'N/A'})`;
                batchDiv.appendChild(title);
                const stagesPresentP = document.createElement('p');
                const presentFixCategories = batch.tasksByFix ? Object.keys(batch.tasksByFix).sort((a,b) => FIX_CATEGORIES_ORDER.indexOf(a) - FIX_CATEGORIES_ORDER.indexOf(b)) : [];
                stagesPresentP.innerHTML = `<strong>Stages Present:</strong> ${presentFixCategories.join(', ') || 'None'}`;
                batchDiv.appendChild(stagesPresentP);
                const releaseActionsDiv = document.createElement('div');
                releaseActionsDiv.classList.add('dashboard-batch-actions-release');
                let latestFixCategoryForBatch = "";
                let allTasksInLatestStageReadyForRelease = false;
                let alreadyReleasedFromLatestStage = true;
                if (batch.tasksByFix) {
                    FIX_CATEGORIES_ORDER.slice().reverse().forEach(fixCat => {
                        if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0 && !latestFixCategoryForBatch) {
                            latestFixCategoryForBatch = fixCat;
                            alreadyReleasedFromLatestStage = batch.tasksByFix[fixCat].every(t => t && t.releasedToNextStage && t.status !== 'Reassigned_TechAbsent');
                            if (!alreadyReleasedFromLatestStage) {
                                allTasksInLatestStageReadyForRelease = batch.tasksByFix[fixCat]
                                    .filter(t => t.status !== 'Reassigned_TechAbsent')
                                    .every(t => t && (t.status === 'Completed' || t.status === 'Day1Ended_AwaitingNext' || t.status === 'Day2Ended_AwaitingNext'));
                            }
                        }
                    });
                }
                if (latestFixCategoryForBatch && !alreadyReleasedFromLatestStage) {
                    const currentFixIdx = FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch);
                    if (currentFixIdx < FIX_CATEGORIES_ORDER.length - 1) {
                        const nextFixCategory = FIX_CATEGORIES_ORDER[currentFixIdx + 1];
                        const releaseBtn = document.createElement('button');
                        releaseBtn.textContent = `Release to ${nextFixCategory}`;
                        releaseBtn.classList.add('btn', 'btn-release');
                        if (!allTasksInLatestStageReadyForRelease) {
                            releaseBtn.disabled = true;
                            releaseBtn.title = `Not all active tasks in ${latestFixCategoryForBatch} are 'Completed' or 'Day 1 Ended' or 'Day 2 Ended'.`;
                        }
                        releaseBtn.onclick = () => releaseBatchToNextFix(batch.batchId, latestFixCategoryForBatch, nextFixCategory);
                        releaseActionsDiv.appendChild(releaseBtn);
                    }
                } else if (alreadyReleasedFromLatestStage && latestFixCategoryForBatch && FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch) < FIX_CATEGORIES_ORDER.length -1) {
                    const releasedInfoP = document.createElement('p');
                    releasedInfoP.innerHTML = `<small><em>(Active tasks released from ${latestFixCategoryForBatch})</em></small>`;
                    releaseActionsDiv.appendChild(releasedInfoP);
                }
                batchDiv.appendChild(releaseActionsDiv);
                const deleteActionsDiv = document.createElement('div');
                deleteActionsDiv.classList.add('dashboard-batch-actions-delete');
                if (batch.tasksByFix) {
                    FIX_CATEGORIES_ORDER.forEach(fixCat => {
                        if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0) {
                            const deleteFixBtn = document.createElement('button');
                            deleteFixBtn.textContent = `Delete ${fixCat} Tasks`;
                            deleteFixBtn.classList.add('btn', 'btn-danger');
                            deleteFixBtn.onclick = () => { if (confirm(`Are you sure you want to delete all ${fixCat} tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteSpecificFixTasksForBatch(batch.batchId, fixCat); };
                            deleteActionsDiv.appendChild(deleteFixBtn);
                        }
                    });
                }
                const deleteAllBtn = document.createElement('button');
                deleteAllBtn.textContent = 'Delete ALL Tasks for this Batch';
                deleteAllBtn.classList.add('btn', 'btn-danger');
                deleteAllBtn.onclick = () => { if (confirm(`Are you sure you want to delete ALL tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteProjectBatch(batch.batchId); };
                deleteActionsDiv.appendChild(deleteAllBtn);
                batchDiv.appendChild(deleteActionsDiv);
                tlDashboardContentElement.appendChild(batchDiv);
            });
            hideLoading(); // Hide loading
        }

        async function releaseBatchToNextFix(batchId, currentFixCategory, nextFixCategory) {
            showLoading(`Releasing ${currentFixCategory} tasks...`); // Show loading
            if (!db) { alert("Database not initialized!"); hideLoading(); return; }
            try {
                const sourceTasksSnapshot = await db.collection("projects").where("batchId", "==", batchId).where("fixCategory", "==", currentFixCategory).where("releasedToNextStage", "==", false).get();
                if (sourceTasksSnapshot.empty) { alert("No active tasks to release."); refreshAllViews(); return; }
                const sourceBatchTasks = [];
                sourceTasksSnapshot.forEach(doc => { const data = doc.data(); if (data.status !== 'Reassigned_TechAbsent') sourceBatchTasks.push({id: doc.id, ...data }); });
                if (sourceBatchTasks.length === 0) { alert("No active tasks to release after filtering."); refreshAllViews(); return; }
                const allReadyForRelease = sourceBatchTasks.every(p => p && (p.status === 'Completed' || p.status === 'Day1Ended_AwaitingNext' || p.status === 'Day2Ended_AwaitingNext'));
                if (!allReadyForRelease) { alert(`Not all active tasks in ${currentFixCategory} are ready. Cannot release.`); return; }
                const releaseTimestamp = firebase.firestore.FieldValue.serverTimestamp();
                const fbBatch = db.batch();
                for (const sourceTask of sourceBatchTasks) {
                    if (!sourceTask || !sourceTask.id) continue;
                    const q = db.collection("projects").where("batchId", "==", sourceTask.batchId).where("areaTask", "==", sourceTask.areaTask).where("fixCategory", "==", nextFixCategory);
                    const existingNextStageTaskSnapshot = await q.get();
                    if (existingNextStageTaskSnapshot.empty) {
                        const newReleasedTaskData = {
                            batchId: sourceTask.batchId, creationTimestamp: sourceTask.creationTimestamp, fixCategory: nextFixCategory,
                            baseProjectName: sourceTask.baseProjectName, areaTask: sourceTask.areaTask, gsd: sourceTask.gsd,
                            assignedTo: sourceTask.assignedTo, techNotes: "", status: 'Available',
                            startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null,
                            startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                            startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null,
                            releasedToNextStage: false, lastModifiedTimestamp: releaseTimestamp,
                            isReassigned: false, originalProjectId: sourceTask.id,
                            breakDurationMinutes: 0, additionalMinutesManual: 0
                        };
                        fbBatch.set(db.collection("projects").doc(), newReleasedTaskData);
                    }
                    fbBatch.update(db.collection("projects").doc(sourceTask.id), { releasedToNextStage: true, lastModifiedTimestamp: releaseTimestamp });
                }
                await fbBatch.commit();
                logActivity(`Released Batch to Next Fix: ${currentFixCategory} -> ${nextFixCategory}`, {
                    batchId: batchId.split('_')[1],
                    currentFixCategory: currentFixCategory,
                    nextFixCategory: nextFixCategory
                });
            } catch (error) { console.error("Error releasing batch:", error); alert("Error: " + error.message); }
            finally { hideLoading(); } // Hide loading
        }

        async function deleteProjectBatch(batchIdToDelete) {
            showLoading("Deleting batch..."); // Show loading
            if (!db || !batchIdToDelete) { hideLoading(); return; }
            try {
                const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).get();
                if (querySnapshot.empty) return;
                const fbBatch = db.batch();
                querySnapshot.forEach(doc => fbBatch.delete(doc.ref));
                await fbBatch.commit();
                logActivity('Deleted Entire Project Batch', { batchId: batchIdToDelete.split('_')[1] });
            } catch (error) { console.error(`Error deleting batch ${batchIdToDelete}:`, error); alert("Error: " + error.message); }
            finally { hideLoading(); } // Hide loading
        }
        async function deleteSpecificFixTasksForBatch(batchIdToDelete, fixCategoryToDelete) {
            showLoading(`Deleting ${fixCategoryToDelete} tasks...`); // Show loading
            if (!db || !batchIdToDelete || !fixCategoryToDelete) { hideLoading(); return; }
            try {
                const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).where("fixCategory", "==", fixCategoryToDelete).get();
                if (querySnapshot.empty) return;
                const fbBatch = db.batch();
                querySnapshot.forEach(doc => fbBatch.delete(doc.ref));
                await fbBatch.commit();
                logActivity(`Deleted Specific Fix Tasks for Batch: ${fixCategoryToDelete}`, { batchId: batchIdToDelete.split('_')[1], fixCategory: fixCategoryToDelete });
            } catch (error) { console.error(`Error deleting ${fixCategoryToDelete} for batch ${batchIdToDelete}:`, error); alert("Error: " + error.message); }
            finally { hideLoading(); } // Hide loading
        }

        function renderProjects() {
            // Note: Loading overlay for renderProjects is handled by initializeFirebaseAndLoadData
            if (!projectTableBody) { console.error("CRITICAL: projectTableBody not found."); return; }
            projectTableBody.innerHTML = '';
            const projectsToRender = [...projects];

            projectsToRender.sort((a, b) => {
                if (!a || !b) return 0;
                // Preserve the original sorting logic for display within the current page
                if ((a.batchId || "") < (b.batchId || "")) return -1; if ((a.batchId || "") > (b.batchId || "")) return 1;
                const fixOrderA = FIX_CATEGORIES_ORDER.indexOf(a.fixCategory || ""); const fixOrderB = FIX_CATEGORIES_ORDER.indexOf(b.fixCategory || "");
                if (fixOrderA < fixOrderB) return -1; if (fixOrderA > fixOrderB) return 1;
                if ((a.areaTask || "") < (b.areaTask || "")) return -1; if ((a.areaTask || "") > (b.areaTask || "")) return 1;
                if ((a.areaTask || "") === (b.areaTask || "")) {
                    let tsA_create = a.creationTimestamp; let tsB_create = b.creationTimestamp;
                    if (tsA_create && typeof tsA_create.toMillis === 'function') tsA_create = tsA_create.toMillis();
                    if (tsB_create && typeof tsB_create.toMillis === 'function') tsB_create = tsB_create.toMillis();
                    tsA_create = typeof tsA_create === 'number' ? tsA_create : 0; tsB_create = typeof tsB_create === 'number' ? tsB_create : 0;
                    if (tsA_create > tsB_create) return -1; if (tsA_create < tsB_create) return 1;
                }
                const statusAVal = STATUS_ORDER[a.status || ""] || 99; const statusBVal = STATUS_ORDER[b.status || ""] || 99;
                if (statusAVal < statusBVal) return -1; if (statusAVal > statusBVal) return 1;
                return 0;
            });

            let currentBatchIdForDisplay = null;
            let currentFixCategoryForHeader = null;

            projectsToRender.forEach(project => {
                if (!project || !project.id || !project.batchId || !project.fixCategory) { return; }

                if (project.batchId !== currentBatchIdForDisplay) {
                    currentBatchIdForDisplay = project.batchId; currentFixCategoryForHeader = null;
                    const batchHeaderRow = projectTableBody.insertRow(); batchHeaderRow.classList.add('batch-header-row');
                    const batchHeaderCell = batchHeaderRow.insertCell(); batchHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString());
                    batchHeaderCell.textContent = `Project Batch: ${project.baseProjectName || 'Unknown'} (ID: ${project.batchId.split('_')[1] || 'N/A'})`;
                }
                if (project.fixCategory !== currentFixCategoryForHeader) {
                    currentFixCategoryForHeader = project.fixCategory;
                    const groupStateKey = `${project.batchId}_${currentFixCategoryForHeader}`;
                    if (groupVisibilityState[groupStateKey] === undefined) groupVisibilityState[groupStateKey] = { isExpanded: true };
                    const groupHeaderRow = projectTableBody.insertRow(); groupHeaderRow.classList.add('fix-group-header');
                    const groupHeaderCell = groupHeaderRow.insertCell(); groupHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString());
                    const toggleBtn = document.createElement('button'); toggleBtn.classList.add('btn', 'btn-group-toggle');
                    const isExpanded = groupVisibilityState[groupStateKey]?.isExpanded !== false;
                    toggleBtn.textContent = isExpanded ? '‚àí' : '+'; toggleBtn.title = isExpanded ? `Collapse ${currentFixCategoryForHeader}` : `Expand ${currentFixCategoryForHeader}`;
                    groupHeaderCell.appendChild(document.createTextNode(`${currentFixCategoryForHeader} `)); groupHeaderCell.appendChild(toggleBtn);
                    groupHeaderCell.onclick = (e) => {
                        if (e.target === toggleBtn || e.target === groupHeaderCell || groupHeaderCell.contains(e.target)) {
                            if (groupVisibilityState[groupStateKey]) {
                                groupVisibilityState[groupStateKey].isExpanded = !groupVisibilityState[groupStateKey].isExpanded;
                                saveGroupVisibilityState(); renderProjects();
                            }
                        }
                    };
                }

                const row = projectTableBody.insertRow();
                const currentGroupStateKeyForRow = `${project.batchId}_${project.fixCategory}`;
                if (!(groupVisibilityState[currentGroupStateKeyForRow]?.isExpanded !== false)) row.classList.add('hidden-group-row');
                if (project.fixCategory) row.classList.add(`${project.fixCategory.toLowerCase()}-row`);
                if (project.isReassigned) row.classList.add('reassigned-task-highlight');

                row.insertCell().textContent = project.fixCategory || 'N/A';
                const baseNameCell = row.insertCell(); baseNameCell.textContent = project.baseProjectName || 'N/A'; baseNameCell.classList.add('wrap-text');
                row.insertCell().textContent = project.areaTask || 'N/A';
                row.insertCell().textContent = project.gsd || 'N/A';

                const assignedToCell = row.insertCell();
                const assignedToSelect = document.createElement('select');
                assignedToSelect.classList.add('assigned-to-select');
                assignedToSelect.disabled = project.status === 'Reassigned_TechAbsent';

                const unassignedOption = document.createElement('option');
                unassignedOption.value = "";
                unassignedOption.textContent = "Select Tech ID";
                assignedToSelect.appendChild(unassignedOption);

                TECH_IDS.forEach(techId => {
                    const option = document.createElement('option');
                    option.value = techId;
                    option.textContent = techId;
                    assignedToSelect.appendChild(option);
                });

                assignedToSelect.value = project.assignedTo || "";

                assignedToSelect.onchange = async (event) => {
                    showLoading("Updating assignment..."); // Show loading
                    const newTechId = event.target.value;
                    const oldTechId = project.assignedTo || "";
                    if (!db || !project.id) {
                        alert("DB or ID missing.");
                        event.target.value = project.assignedTo || '';
                        hideLoading();
                        return;
                    }
                    try {
                        await db.collection("projects").doc(project.id).update({
                            assignedTo: newTechId,
                            lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        logActivity('Changed Assigned Tech', {
                            projectId: project.id,
                            projectName: project.baseProjectName + ' ' + project.areaTask,
                            oldAssignedTo: oldTechId,
                            newAssignedTo: newTechId
                        });
                        project.assignedTo = newTechId;
                    } catch (error) {
                        console.error("Error updating assignedTo:", error);
                        alert("Error: " + error.message);
                        event.target.value = project.assignedTo || '';
                    } finally {
                        hideLoading(); // Hide loading
                    }
                };
                assignedToCell.appendChild(assignedToSelect);

                const statusCell = row.insertCell();
                const statusSpan = document.createElement('span'); statusSpan.classList.add('status');
                let statusText = (project.status || "Unknown").replace(/([A-Z])(?=[a-z0-9_])/g, ' $1').trim();
                if (project.status === "Day1Ended_AwaitingNext") statusText = "Started Available";
                if (project.status === "Day2Ended_AwaitingNext") statusText = "Started Day 2 Ended";
                if (project.status === "Reassigned_TechAbsent") statusText = "Re-Assigned";
                statusSpan.textContent = statusText; statusSpan.classList.add(`status-${(project.status || "unknown").toLowerCase()}`);
                statusCell.appendChild(statusSpan);

                const timeFormatOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
                let d1s = project.startTimeDay1, d1f = project.finishTimeDay1,
                    d2s = project.startTimeDay2, d2f = project.finishTimeDay2,
                    d3s = project.startTimeDay3, d3f = project.finishTimeDay3;

                try {
                    if (d1s && typeof d1s.toDate === 'function') d1s = d1s.toDate(); else if (d1s) d1s = new Date(d1s); else d1s = null;
                    if (d1f && typeof d1f.toDate === 'function') d1f = d1f.toDate(); else if (d1f) d1f = new Date(d1f); else d1f = null;
                    if (d2s && typeof d2s.toDate === 'function') d2s = d2s.toDate(); else if (d2s) d2s = new Date(d2s); else d2s = null;
                    if (d2f && typeof d2f.toDate === 'function') d2f = d2f.toDate(); else if (d2f) d2f = new Date(d2f); else d2f = null;
                    if (d3s && typeof d3s.toDate === 'function') d3s = d3s.toDate(); else if (d3s) d3s = new Date(d3s); else d3s = null;
                    if (d3f && typeof d3f.toDate === 'function') d3f = d3f.toDate(); else if (d3f) d3f = new Date(d3f); else d3f = null;

                } catch (dateError) { d1s = d1f = d2s = d2f = d3s = d3f = null; }

                row.insertCell().textContent = d1s && !isNaN(d1s) ? d1s.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d1f && !isNaN(d1f) ? d1f.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d2s && !isNaN(d2s) ? d2s.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d2f && !isNaN(d2f) ? d2f.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d3s && !isNaN(d3s) ? d3s.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d3f && !isNaN(d3f) ? d3f.toLocaleTimeString('en-US', timeFormatOptions) : '-';

                let totalRawDurationMs = (project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) + (project.durationDay3Ms || 0);
                let breakToSubtractMs = (project.breakDurationMinutes || 0) * 60000;
                let additionalManualMs = (project.additionalMinutesManual || 0) * 60000;
                let durationAfterBreakMs = Math.max(0, totalRawDurationMs - breakToSubtractMs);
                let finalTotalDurationMs = durationAfterBreakMs + additionalManualMs;
                if (totalRawDurationMs === 0 && (project.breakDurationMinutes || 0) === 0 && (project.additionalMinutesManual || 0) === 0) {
                    finalTotalDurationMs = null;
                }
                const totalDurationCell = row.insertCell();
                totalDurationCell.textContent = formatMillisToMinutes(finalTotalDurationMs);
                totalDurationCell.classList.add('total-duration-column');

                const techNotesCell = row.insertCell();
                const techNotesInput = document.createElement('textarea'); techNotesInput.value = project.techNotes || '';
                techNotesInput.placeholder = 'Notes'; techNotesInput.classList.add('tech-notes-input'); techNotesInput.rows = 1;
                techNotesInput.id = `techNotes_${project.id}`; techNotesInput.disabled = project.status === 'Reassigned_TechAbsent';
                techNotesInput.onchange = async (event) => {
                    showLoading("Updating tech notes..."); // Show loading
                    const newVal = event.target.value;
                    const oldVal = project.techNotes || '';
                    if (!db || !project.id) { event.target.value = project.techNotes || ''; hideLoading(); return; }
                    try {
                        await db.collection("projects").doc(project.id).update({ techNotes: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() });
                        logActivity('Updated Tech Notes', {
                            projectId: project.id,
                            projectName: project.baseProjectName + ' ' + project.areaTask,
                            oldNotes: oldVal,
                            newNotes: newVal.length > 50 ? newVal.substring(0, 50) + '...' : newVal
                        });
                    } catch (error) {
                        console.error("Error updating techNotes:", error);
                        event.target.value = project.techNotes || '';
                    } finally {
                        hideLoading(); // Hide loading
                    }
                };
                techNotesCell.appendChild(techNotesInput);

                const actionsCell = row.insertCell();
                const btnContainer = document.createElement('div');

                const breakSelect = document.createElement('select');
                breakSelect.classList.add('break-select'); breakSelect.id = `breakSelect_${project.id}`;
                breakSelect.title = "Select break time to deduct"; breakSelect.disabled = project.status === 'Reassigned_TechAbsent';
                let defaultBreakOption = document.createElement('option'); defaultBreakOption.value = '0'; defaultBreakOption.textContent = 'No Break'; breakSelect.appendChild(defaultBreakOption);
                let option15Min = document.createElement('option'); option15Min.value = '15'; option15Min.textContent = '15m Break'; breakSelect.appendChild(option15Min);
                let option60Min = document.createElement('option'); option60Min.value = '60'; option60Min.textContent = '1h Break'; breakSelect.appendChild(option60Min);
                let option90Min = document.createElement('option'); option90Min.value = '90'; option90Min.textContent = '1h30m Break'; breakSelect.appendChild(option90Min);
                breakSelect.value = (typeof project.breakDurationMinutes === 'number') ? project.breakDurationMinutes.toString() : '0';
                breakSelect.onchange = async (event) => {
                    showLoading("Updating break duration..."); // Show loading
                    const selectedBreakMinutes = parseInt(event.target.value, 10);
                    const oldBreakMinutes = project.breakDurationMinutes || 0;
                    if (!db || !project.id) { event.target.value = project.breakDurationMinutes ? project.breakDurationMinutes.toString() : '0'; hideLoading(); return; }
                    try {
                        await db.collection("projects").doc(project.id).update({
                            breakDurationMinutes: selectedBreakMinutes,
                            lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        logActivity('Updated Break Duration', {
                            projectId: project.id,
                            projectName: project.baseProjectName + ' ' + project.areaTask,
                            oldValue: oldBreakMinutes,
                            newValue: selectedBreakMinutes
                        });
                        const currentRow = event.target.closest('tr');
                         if (currentRow) {
                            const totalCellInRow = currentRow.querySelector('.total-duration-column');
                            if (totalCellInRow) {
                                let currentTotalRawMs = (project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) + (project.durationDay3Ms || 0);
                                let currentBreakMs = selectedBreakMinutes * 60000;
                                let currentAdditionalMs = (project.additionalMinutesManual || 0) * 60000;
                                let currentDurationAfterBreakMs = Math.max(0, currentTotalRawMs - currentBreakMs);
                                let currentFinalTotalMs = currentDurationAfterBreakMs + currentAdditionalMs;
                                if (currentTotalRawMs === 0 && selectedBreakMinutes === 0 && (project.additionalMinutesManual || 0) === 0) { currentFinalTotalMs = null; }
                                totalCellInRow.textContent = formatMillisToMinutes(currentFinalTotalMs);
                                project.breakDurationMinutes = selectedBreakMinutes;
                            }
                        }
                    } catch (error) {
                        console.error("Error updating break duration:", error);
                        event.target.value = project.breakDurationMinutes ? project.breakDurationMinutes.toString() : '0';
                    } finally {
                        hideLoading(); // Hide loading
                    }
                };
                btnContainer.appendChild(breakSelect);

                const isOriginalReassignedTask = project.status === 'Reassigned_TechAbsent';
                const sD1btn = document.createElement('button'); sD1btn.textContent = 'Start D1'; sD1btn.classList.add('btn','btn-day-start');
                sD1btn.disabled = isOriginalReassignedTask || !(project.status === 'Available' || project.status === 'Day1Ended_AwaitingNext' || project.status === 'InProgressDay2' || project.status === 'Day2Ended_AwaitingNext' || project.status === 'InProgressDay3' || project.status === 'Completed');
                sD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay1'); }; btnContainer.appendChild(sD1btn);

                const eD1btn = document.createElement('button'); eD1btn.textContent = 'End D1'; eD1btn.classList.add('btn','btn-day-end'); eD1btn.disabled = project.status !== 'InProgressDay1' || isOriginalReassignedTask; eD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay1'); }; btnContainer.appendChild(eD1btn);

                const sD2btn = document.createElement('button'); sD2btn.textContent = 'Start D2'; sD2btn.classList.add('btn','btn-day-start');
                sD2btn.disabled = isOriginalReassignedTask || !(project.status === 'Day1Ended_AwaitingNext' || project.status === 'Day2Ended_AwaitingNext' || project.status === 'InProgressDay3' || project.status === 'Completed');
                sD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay2'); }; btnContainer.appendChild(sD2btn);

                const eD2btn = document.createElement('button'); eD2btn.textContent = 'End D2'; eD2btn.classList.add('btn','btn-day-end');
                eD2btn.disabled = project.status !== 'InProgressDay2' || isOriginalReassignedTask; eD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay2'); }; btnContainer.appendChild(eD2btn);

                const sD3btn = document.createElement('button'); sD3btn.textContent = 'Start D3'; sD3btn.classList.add('btn','btn-day-start');
                sD3btn.disabled = isOriginalReassignedTask || !(project.status === 'Day2Ended_AwaitingNext' || project.status === 'InProgressDay3' || project.status === 'Completed');
                sD3btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay3'); }; btnContainer.appendChild(sD3btn);

                const eD3btn = document.createElement('button'); eD3btn.textContent = 'End D3'; eD3btn.classList.add('btn','btn-day-end');
                eD3btn.disabled = project.status !== 'InProgressDay3' || isOriginalReassignedTask; eD3btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay3'); }; btnContainer.appendChild(eD3btn);


                const doneBtn = document.createElement('button'); doneBtn.textContent = 'Done'; doneBtn.classList.add('btn','btn-mark-done'); doneBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; doneBtn.onclick = () => { if (project.id) updateProjectState(project.id, 'markDone'); }; btnContainer.appendChild(doneBtn);
                const reassignBtn = document.createElement('button'); reassignBtn.textContent = 'Re-Assign'; reassignBtn.classList.add('btn', 'btn-warning'); reassignBtn.title = 'Re-assign task by creating a new entry.'; reassignBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; reassignBtn.onclick = () => { const currentProjectData = projects.find(p => p.id === project.id); if (currentProjectData) handleReassignment(currentProjectData); }; btnContainer.appendChild(reassignBtn);

                actionsCell.appendChild(btnContainer);
            });
        }

        async function updateProjectState(projectId, action) {
            showLoading("Updating project state..."); // Show loading
            if (!db || !projectId ) { hideLoading(); return; }
            const projectRef = db.collection("projects").doc(projectId);
            let currentProjectData;
            try {
                const doc = await projectRef.get();
                if (!doc.exists) { hideLoading(); return; }
                currentProjectData = doc.data();
            } catch(error) {
                console.error("Error fetching current project data for update:", error);
                hideLoading();
                return;
            }
            if (!currentProjectData || currentProjectData.status === 'Reassigned_TechAbsent') { hideLoading(); return; }

            const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp();
            const clientNowMillis = Date.now();
            let updatedFields = { lastModifiedTimestamp: serverTimestamp };
            let oldStatus = currentProjectData.status;
            let newStatus = oldStatus;

            switch (action) {
                case 'startDay1':
                    if (['Available', 'Day1Ended_AwaitingNext', 'InProgressDay2', 'Day2Ended_AwaitingNext', 'InProgressDay3', 'Completed'].includes(currentProjectData.status)) {
                        updatedFields = {
                            ...updatedFields,
                            status: 'InProgressDay1',
                            startTimeDay1: serverTimestamp,
                            finishTimeDay1: null, durationDay1Ms: null,
                            startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                            startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null
                        };
                        newStatus = 'InProgressDay1';
                    } break;
                case 'endDay1':
                    if (currentProjectData.status === 'InProgressDay1' && currentProjectData.startTimeDay1) {
                        updatedFields = { ...updatedFields, status: 'Day1Ended_AwaitingNext', finishTimeDay1: serverTimestamp, durationDay1Ms: calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis) };
                        newStatus = 'Day1Ended_AwaitingNext';
                    }
                    break;
                case 'startDay2':
                    if (['Day1Ended_AwaitingNext', 'Day2Ended_AwaitingNext', 'InProgressDay3', 'Completed'].includes(currentProjectData.status)) {
                        updatedFields = {
                            ...updatedFields,
                            status: 'InProgressDay2',
                            startTimeDay2: serverTimestamp,
                            finishTimeDay2: null, durationDay2Ms: null,
                            startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null
                        };
                        newStatus = 'InProgressDay2';
                    }
                    break;
                case 'endDay2':
                    if (currentProjectData.status === 'InProgressDay2' && currentProjectData.startTimeDay2) {
                        updatedFields = { ...updatedFields, status: 'Day2Ended_AwaitingNext', finishTimeDay2: serverTimestamp, durationDay2Ms: calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis) };
                        newStatus = 'Day2Ended_AwaitingNext';
                    }
                    break;
                case 'startDay3':
                    if (['Day2Ended_AwaitingNext', 'InProgressDay3', 'Completed'].includes(currentProjectData.status)) {
                        updatedFields = { ...updatedFields, status: 'InProgressDay3', startTimeDay3: serverTimestamp, finishTimeDay3: null, durationDay3Ms: null };
                        newStatus = 'InProgressDay3';
                    }
                    break;
                case 'endDay3':
                    if (currentProjectData.status === 'InProgressDay3' && currentProjectData.startTimeDay3) {
                        updatedFields = { ...updatedFields, status: 'Completed', finishTimeDay3: serverTimestamp, durationDay3Ms: calculateDurationMs(currentProjectData.startTimeDay3, clientNowMillis) };
                        newStatus = 'Completed';
                    }
                    break;
                case 'markDone':
                    if (currentProjectData.status !== 'Completed') {
                        updatedFields.status = 'Completed';
                        newStatus = 'Completed';
                        if (currentProjectData.startTimeDay1 && !currentProjectData.finishTimeDay1) { updatedFields.finishTimeDay1 = serverTimestamp; updatedFields.durationDay1Ms = calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis); }
                        if (currentProjectData.startTimeDay2 && !currentProjectData.finishTimeDay2) { updatedFields.finishTimeDay2 = serverTimestamp; updatedFields.durationDay2Ms = calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis); }
                        if (currentProjectData.startTimeDay3 && !currentProjectData.finishTimeDay3) { updatedFields.finishTimeDay3 = serverTimestamp; updatedFields.durationDay3Ms = calculateDurationMs(currentProjectData.startTimeDay3, clientNowMillis); }
                        if (!currentProjectData.startTimeDay1 && !currentProjectData.startTimeDay2 && !currentProjectData.startTimeDay3) {
                            // No start times, no duration to calculate for any day
                        } else if (!currentProjectData.startTime2 && currentProjectData.startTime1 && !currentProjectData.finishTime1) {
                            updatedFields.finishTimeDay1 = serverTimestamp;
                            updatedFields.durationDay1Ms = calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis);
                        } else if (currentProjectData.startTime1 && currentProjectData.finishTime1 && !currentProjectData.startTime2) {
                            updatedFields.startTimeDay2 = null; updatedFields.finishTimeDay2 = null; updatedFields.durationDay2Ms = null;
                            updatedFields.startTimeDay3 = null; updatedFields.finishTimeDay3 = null; updatedFields.durationDay3Ms = null;
                        } else if (currentProjectData.startTime2 && !currentProjectData.finishTime2) {
                             updatedFields.finishTimeDay2 = serverTimestamp;
                             updatedFields.durationDay2Ms = calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis);
                             updatedFields.startTimeDay3 = null; updatedFields.finishTimeDay3 = null; updatedFields.durationDay3Ms = null;
                        } else if (currentProjectData.startTime2 && currentProjectData.finishTime2 && !currentProjectData.startTime3) {
                            updatedFields.startTimeDay3 = null; updatedFields.finishTimeDay3 = null; updatedFields.durationDay3Ms = null;
                        }
                    } break;
                default: hideLoading(); return; // Important: hide loading if action is not handled
            }
            if (Object.keys(updatedFields).length > 1) {
                try {
                    await projectRef.update(updatedFields);
                    logActivity(`Updated Project Status: ${action}`, {
                        projectId: projectId,
                        projectName: currentProjectData.baseProjectName + ' ' + currentProjectData.areaTask,
                        oldStatus: oldStatus,
                        newStatus: newStatus
                    });
                }
                catch (error) { console.error(`Error updating project ${projectId}:`, error); }
                finally { hideLoading(); } // Always hide loading
            } else {
                hideLoading(); // Hide loading if no updates were made
            }
        }

        async function handleReassignment(originalProjectData) {
            if (!originalProjectData || !originalProjectData.id || originalProjectData.status === 'Reassigned_TechAbsent' || originalProjectData.status === 'Completed') return;
            const newTechId = prompt(`Task for '${originalProjectData.areaTask}'. Enter New Tech ID:`);
            if (newTechId === null || newTechId.trim() === "") return;

            if (confirm(`Create NEW task for '${newTechId.trim()}'? Current task will be closed.`)) {
                showLoading("Reassigning task..."); // Show loading
                if (!db) { hideLoading(); return; }
                const batch = db.batch(); const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp();
                const newReassignedData = {
                    batchId: originalProjectData.batchId, baseProjectName: originalProjectData.baseProjectName,
                    areaTask: originalProjectData.areaTask, gsd: originalProjectData.gsd, fixCategory: originalProjectData.fixCategory,
                    assignedTo: newTechId.trim(), status: 'Available',
                    startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null,
                    startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                    startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null,
                    techNotes: `Reassigned from ${originalProjectData.assignedTo || 'N/A'}. Original Project ID: ${originalProjectData.id}`, creationTimestamp: serverTimestamp, lastModifiedTimestamp: serverTimestamp,
                    isReassigned: true, originalProjectId: originalProjectData.id, releasedToNextStage: false,
                    breakDurationMinutes: 0, additionalMinutesManual: 0
                };
                const newDocRef = db.collection("projects").doc();
                batch.set(newDocRef, newReassignedData);
                batch.update(db.collection("projects").doc(originalProjectData.id), { status: 'Reassigned_TechAbsent', lastModifiedTimestamp: serverTimestamp });
                try {
                    await batch.commit();
                    logActivity('Reassigned Task', {
                        originalProjectId: originalProjectData.id,
                        originalProjectName: originalProjectData.baseProjectName + ' ' + originalProjectData.areaTask,
                        oldAssignedTo: originalProjectData.assignedTo,
                        newAssignedTo: newTechId.trim(),
                        newProjectId: newDocRef.id
                    });
                } catch (error) { console.error("Error in re-assignment:", error); }
                finally { hideLoading(); } // Hide loading
            }
        }

        function refreshAllViews() {
            // Note: Loading overlay for refreshAllViews is handled by the calling functions
            try {
                renderProjects();
                if (tlDashboardModal && tlDashboardModal.style.display === 'block') {
                    renderTLSummary(); // Re-render TL Summary on refresh
                    renderTLDashboard();
                }
                if (settingsModal && settingsModal.style.display === 'block') renderAllowedEmailsList();
                if (activityLogModal && activityLogModal.style.display === 'block') renderActivityLog();
            } catch (e) { console.error("Error during refreshAllViews:", e); }
        }

        async function renderAllowedEmailsList() {
            // Note: Loading overlay for renderAllowedEmailsList is handled by fetchAllowedEmails
            if (!allowedEmailsList) return; await fetchAllowedEmails(); allowedEmailsList.innerHTML = '';
            if (allowedEmailsFromFirestore.length === 0) { allowedEmailsList.innerHTML = '<li>No allowed emails configured.</li>'; return; }
            allowedEmailsFromFirestore.forEach(email => {
                const li = document.createElement('li'); li.textContent = email;
                const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => handleRemoveEmail(email); li.appendChild(removeBtn);
                allowedEmailsList.appendChild(li);
            });
        }
        async function handleAddEmail() {
            showLoading("Adding email..."); // Show loading
            if (!addEmailInput) { hideLoading(); return; }
            const newEmail = addEmailInput.value.trim().toLowerCase();
            if (!newEmail || !newEmail.includes('@')) { alert("Please enter a valid email address."); hideLoading(); return; }
            if (allowedEmailsFromFirestore.map(e => e.toLowerCase()).includes(newEmail)) { alert("This email is already in the allowed list."); hideLoading(); return; }
            const updatedEmails = [...allowedEmailsFromFirestore, newEmail].sort();
            if (await updateAllowedEmailsInFirestore(updatedEmails)) {
                logActivity('Added Allowed Email', { email: newEmail });
                addEmailInput.value = ''; renderAllowedEmailsList();
            }
            // updateAllowedEmailsInFirestore already handles hiding the loading spinner in its finally block.
        }
        async function handleRemoveEmail(emailToRemove) {
            if (confirm(`Remove ${emailToRemove} from allowed list?`)) {
                showLoading("Removing email..."); // Show loading
                const updatedEmails = allowedEmailsFromFirestore.filter(email => email !== emailToRemove);
                if (await updateAllowedEmailsInFirestore(updatedEmails)) {
                    logActivity('Removed Allowed Email', { email: emailToRemove });
                    renderAllowedEmailsList();
                }
                // updateAllowedEmailsInFirestore already handles hiding the loading spinner in its finally block.
            }
        }

        function setupAuthEventListeners() {
            const provider = new firebase.auth.GoogleAuthProvider();

            if (signInBtn) {
                signInBtn.addEventListener('click', () => {
                    showLoading("Signing in..."); // Show loading
                    if (!auth) { console.error("Auth not initialized"); hideLoading(); return; }
                    auth.signInWithPopup(provider)
                        .then((result) => {
                            console.log("Sign-in attempt successful for: ", result.user.email);
                            // Loading hides after auth state change, which triggers initializeAppComponents
                        })
                        .catch((error) => {
                            console.error("Sign-in error: ", error);
                            let errorMessage = "Error signing in: " + error.message;
                            if (error.code === 'auth/popup-closed-by-user') {
                                errorMessage = "Sign-in process was cancelled. Please try again.";
                            } else if (error.code === 'auth/cancelled-popup-request') {
                                errorMessage = "Sign-in process was interrupted. Please try again.";
                            } else if (error.code === 'auth/popup-blocked') {
                                errorMessage = "Sign-in pop-up was blocked by the browser. Please allow pop-ups for this site and try again.";
                            }
                            alert(errorMessage);
                            if (loadingAuthMessageDiv && signInBtn && userInfoDisplayDiv && appContentDiv) {
                                userInfoDisplayDiv.style.display = 'none';
                                signInBtn.style.display = 'block';
                                appContentDiv.style.display = 'none';
                                loadingAuthMessageDiv.innerHTML = '<p>Please sign in to access the Project Tracker.</p>';
                                loadingAuthMessageDiv.style.display = 'block';
                            }
                            hideLoading(); // Hide loading on sign-in error
                        });
                });
            } else {
                console.error("Sign-in button not found during event listener setup.");
            }

            if (signOutBtn) {
                signOutBtn.addEventListener('click', () => {
                    showLoading("Signing out..."); // Show loading
                    if (!auth) { console.error("Auth not initialized"); hideLoading(); return; }
                    auth.signOut()
                        .then(() => {
                            console.log("User signed out successfully by clicking button.");
                            // Loading hides after auth state change
                        })
                        .catch((error) => {
                            console.error("Sign-out error: ", error);
                            alert("Error signing out: " + error.message);
                            hideLoading(); // Hide loading on sign-out error
                        });
                });
            } else {
                console.error("Sign-out button not found during event listener setup.");
            }
        }

        function initializeAppComponents() {
            if (!isAppInitialized) {
                console.log("Initializing app components (DOM refs, event listeners, Firestore data)...");
                setupDOMReferences();
                attachEventListeners();
                lastVisibleDoc = null;
                firstVisibleDoc = null;
                queryHistory = [];
                currentPage = 0;
                initializeFirebaseAndLoadData();
                isAppInitialized = true;
            } else {
                console.log("App components already initialized or re-initializing data load.");
                initializeFirebaseAndLoadData();
            }
        }

        // Main authentication state change listener
        if (auth) {
            auth.onAuthStateChanged(async (user) => {
                setupDOMReferences();
                setupAuthRelatedDOMReferences();

                if (!userNameP || !userEmailP || !userPhotoImg || !userInfoDisplayDiv || !signInBtn || !appContentDiv || !loadingAuthMessageDiv || !openSettingsBtn) {
                    console.error("One or more critical UI elements for auth state change not found. Aborting UI update.");
                    hideLoading(); // Hide loading if UI elements are missing
                    return;
                }

                if (user) {
                    showLoading("Checking authorization..."); // Show loading during authorization check
                    await fetchAllowedEmails();
                    const userEmailLower = user.email ? user.email.toLowerCase() : "";

                    if (user.email && allowedEmailsFromFirestore.map(email => email.toLowerCase()).includes(userEmailLower)) {
                        console.log("Auth state changed: User is SIGNED IN and ALLOWED - ", user.displayName, user.email);

                        userNameP.textContent = user.displayName || "Name not available";
                        userEmailP.textContent = user.email || "Email not available";
                        userPhotoImg.src = user.photoURL || "default-user.png";

                        userInfoDisplayDiv.style.display = 'flex';
                        signInBtn.style.display = 'none';
                        loadingAuthMessageDiv.style.display = 'none';
                        appContentDiv.style.display = 'block';
                        openSettingsBtn.style.display = 'block';

                        initializeAppComponents();
                        // Loading will be hidden by initializeFirebaseAndLoadData
                    } else {
                        console.warn("Auth state changed: User SIGNED IN but NOT ALLOWED - ", user.email);
                        alert("Access Denied: Your email address (" + (user.email || "N/A") + ") is not authorized to use this application.");

                        auth.signOut().then(() => {
                            console.log("Unauthorized user automatically signed out.");
                            loadingAuthMessageDiv.innerHTML = '<p>Access Denied. Please sign in with an authorized account.</p>';
                            userInfoDisplayDiv.style.display = 'none';
                            signInBtn.style.display = 'block';
                            appContentDiv.style.display = 'none';
                            loadingAuthMessageDiv.style.display = 'block';
                            openSettingsBtn.style.display = 'none';

                            projects = [];
                            if (projectTableBody) projectTableBody.innerHTML = '';
                            if (tlDashboardContentElement) tlDashboardContentElement.innerHTML = '';
                            if (allowedEmailsList) allowedEmailsList.innerHTML = '';
                            if (tlSummaryContentElement) tlSummaryContentElement.innerHTML = ''; // Clear TL summary
                            if (firestoreListenerUnsubscribe) {
                                firestoreListenerUnsubscribe();
                                firestoreListenerUnsubscribe = null;
                                console.log("Firestore listener detached for unauthorized user sign out.");
                            }
                            isAppInitialized = false;
                            hideLoading(); // Hide loading after handling unauthorized sign out
                        }).catch(error => {
                            console.error("Error signing out unauthorized user:", error);
                            userInfoDisplayDiv.style.display = 'none';
                            signInBtn.style.display = 'block';
                            appContentDiv.style.display = 'none';
                            loadingAuthMessageDiv.innerHTML = '<p>Access Denied. Error during sign out. Please refresh.</p>';
                            loadingAuthMessageDiv.style.display = 'block';
                            openSettingsBtn.style.display = 'none';
                            hideLoading(); // Hide loading even if sign out fails
                        });
                    }

                } else {
                    console.log("Auth state changed: User is SIGNED OUT");

                    userNameP.textContent = '';
                    userEmailP.textContent = '';
                    userPhotoImg.src = '';

                    userInfoDisplayDiv.style.display = 'none';
                    signInBtn.style.display = 'block';
                    appContentDiv.style.display = 'none';
                    openSettingsBtn.style.display = 'none';

                    if (loadingAuthMessageDiv.innerHTML.indexOf("Access Denied") === -1) {
                         loadingAuthMessageDiv.innerHTML = '<p>Please sign in to access the Project Tracker.</p>';
                    }
                    loadingAuthMessageDiv.style.display = 'block';

                    projects = [];
                    if (projectTableBody) projectTableBody.innerHTML = '';
                    if (tlDashboardContentElement) tlDashboardContentElement.innerHTML = '';
                    if (allowedEmailsList) allowedEmailsList.innerHTML = '';
                    if (tlSummaryContentElement) tlSummaryContentElement.innerHTML = ''; // Clear TL summary
                    if (firestoreListenerUnsubscribe) {
                        firestoreListenerUnsubscribe();
                        firestoreListenerUnsubscribe = null;
                        console.log("Firestore listener detached on sign out.");
                    }
                    isAppInitialized = false;
                    console.log("App content hidden, project data cleared, and Firestore listener detached.");
                    hideLoading(); // Ensure loading is hidden when signed out
                }
            });
        } else {
            console.error("Firebase Auth is not initialized. UI updates based on auth state will not occur.");
            if (loadingAuthMessageDiv) {
                loadingAuthMessageDiv.innerHTML = `<p style="color:red; font-weight:bold;">Authentication services could not be loaded. Please check the console and refresh.</p>`;
                loadingAuthMessageDiv.style.display = 'block';
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");
            setupDOMReferences();
            setupAuthRelatedDOMReferences();

            if (auth) {
                setupAuthEventListeners();
                console.log("Auth UI and event listeners set up.");
            } else {
                console.error("Firebase Auth not available on DOMContentLoaded. Auth UI setup skipped.");
                const authContainer = document.getElementById('auth-container');
                if (authContainer && loadingAuthMessageDiv) {
                    loadingAuthMessageDiv.innerHTML = '<p style="color:red; font-weight:bold;">Authentication services could not be loaded. Please check the console and refresh.</p>';
                    loadingAuthMessageDiv.style.display = 'block';
                }
            }
        });
    </script>
</body>
</html>
