<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f7f6; color: #333; line-height: 1.4; }
        .container { width: 98%; max-width: 1900px; margin: 10px auto; padding: 10px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 5px; }
        h1, h2, h3 { color: #2c3e50; text-align: center; margin-bottom: 12px; font-size: 1.5em; }
        h2 { font-size: 1.3em; }
        h3 { font-size: 1.1em; text-align: left; margin-top: 15px; border-bottom: 1px solid #ccc; padding-bottom: 5px;}
        .action-bar { margin-bottom: 15px; display: flex; gap: 10px; }
        .btn { padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8em; transition: background-color 0.3s ease; margin: 2px; min-width: 60px; text-align: center; vertical-align: middle;}
        .btn-lg { padding: 7px 12px; font-size: 0.9em; }
        .btn-group-toggle { min-width: 25px; padding: 2px 6px; font-size: 0.9em; margin-left: 10px; background-color: #7f8c8d; color:white; }
        .btn-group-toggle:hover { background-color: #95a5a6;}
        .btn-danger { background-color: #e74c3c; color: white; } .btn-danger:hover { background-color: #c0392b; }
        .btn-primary { background-color: #3498db; color: white; } .btn-primary:hover { background-color: #2980b9; }
        .btn-success { background-color: #2ecc71; color: white; } .btn-success:hover { background-color: #27ae60; }
        .btn-mark-done { background-color: #1abc9c; color: white; } .btn-mark-done:hover { background-color: #16a085; }
        .btn-release { background-color: #9b59b6; color: white; font-size:0.85em; padding: 5px 10px; } .btn-release:hover { background-color: #8e44ad; }
        .btn-day-start { background-color: #007bff; color: white; }
        .btn-day-start:hover { background-color: #0056b3; }
        .btn-day-end { background-color: #fd7e14; color: white; }
        .btn-day-end:hover { background-color: #c85e08; }
        .btn-warning { background-color: #f39c12; color: white; }
        .btn-warning:hover { background-color: #e67e22; }
        .btn:disabled { background-color: #bdc3c7 !important; color: #7f8c8d !important; cursor: not-allowed; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 15px; border: 1px solid #888; width: 90%; border-radius: 5px; position: relative; }
        #projectFormModal .modal-content { max-width: 480px; }
        #tlDashboardModal .modal-content { max-width: 750px; max-height: 85vh; overflow-y: auto;}
        .close-button { color: #aaa; float: right; font-size: 24px; font-weight: bold; } .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #newProjectForm label { display: block; margin-top: 8px; font-weight: bold; font-size: 0.85em;}
        #newProjectForm input[type="text"], #newProjectForm input[type="number"], #newProjectForm select { width: calc(100% - 18px); padding: 7px; margin-top: 3px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box; font-size: 0.85em; }
        #newProjectForm button[type="submit"] { margin-top: 12px; }
        #projectTable { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.8em; }
        #projectTable th, #projectTable td { border: 1px solid #ddd; padding: 3px 5px; text-align: left; vertical-align: middle; white-space: nowrap; }
        #projectTable thead th { background-color: #34495e; color: white; font-weight: bold; position: sticky; top: 0; z-index: 10;}
        #projectTable td.wrap-text { white-space: normal; }
        #projectTable input[type="text"].assigned-to-input, #projectTable textarea.tech-notes-input { width: calc(100% - 6px); padding: 2px; border: 1px solid #ccc; border-radius: 2px; box-sizing: border-box; font-size: 1em; background-color: #fff; }
        #projectTable textarea.tech-notes-input { resize: vertical; min-height: 18px; line-height: 1.3; }
        .batch-header-row td { background-color: #6c757d !important; color: white; font-size: 1.1em; font-weight: bold; text-align: left; padding: 6px 8px; }
        .fix-group-header td { background-color: #adb5bd !important; color: #212529; font-size: 1.0em; font-weight: bold; text-align: left; padding: 4px 8px; cursor:pointer; padding-left: 30px; }
        .hidden-group-row { display: none; }
        .overall-project-separator td { height: 10px !important; background-color: #e9ecef !important; border: none !important; padding: 0 !important; }
        #projectTable td.duration-column { color: #0056b3; font-weight: bold; }
        #projectTable td.total-duration-column { color: #004085; font-weight: bold; background-color: #f0f4f8; }

        /* MODIFIED: Removed !important to allow override by reassigned-task-highlight */
        .fix1-row { background-color: #e6ffe6; }
        .fix2-row { background-color: #ffe6f2; }
        .fix3-row { background-color: #e6e6ff; }
        .fix4-row { background-color: #fff5e6; }

        /* ADDED: Style for reassigned tasks highlight. Using !important to ensure it overrides if needed. */
        .reassigned-task-highlight {
            background-color: #FFF9C4 !important; /* Light yellow */
        }

        #projectTable tbody tr:not(.fix-group-header):not(.batch-header-row):not(.overall-project-separator):hover {
            background-color: #d0e0f0 !important;
        }
        .status { padding: 2px 5px; border-radius: 3px; color: white; font-weight: bold; text-align: center; display: inline-block; font-size:0.95em; }
        .status-available { background-color: #3498db; }
        .status-inprogressday1 { background-color: #f39c12; }
        .status-day1ended_awaitingnext { background-color: #f39c12; }
        .status-inprogressday2 { background-color: #f39c12; }
        .status-completed { background-color: #2ecc71; }
        /* ADDED: Style for the status of an original task that has been reassigned */
        .status-reassigned_techabsent { background-color: #B0BEC5; color: #263238; }

        #tlDashboardContent { margin-top:15px; }
        .dashboard-batch-item { border: 1px solid #bdc3c7; padding: 10px; margin-bottom: 10px; background-color: #fff; border-radius: 4px; }
        .dashboard-batch-item h4 { margin-top: 0; margin-bottom: 8px; font-size: 1.05em; color: #34495e;}
        .dashboard-batch-item p { margin: 3px 0; font-size: 0.9em;}
        .dashboard-batch-actions-release { margin-top: 8px; margin-bottom: 8px; }
        .dashboard-batch-actions-delete { margin-top: 8px; border-top: 1px dashed #ccc; padding-top: 8px; display: flex; flex-wrap: wrap; gap: 5px;}
    </style>
</head>
<body>
    <div class="container">
        <h1>123 Project Tracker</h1>
        <div class="action-bar">
            <button id="openAddNewProjectBtn" class="btn btn-success btn-lg">âž• Add New Tracker</button>
            <button id="openTlDashboardBtn" class="btn btn-primary btn-lg">ðŸ‘‘ TL Dashboard</button>
        </div>

        <div id="projectFormModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeProjectFormBtn">&times;</span>
                <h2>Add New Tracker</h2>
                <form id="newProjectForm">
                    <label for="fixCategorySelect">Fix Category:</label>
                    <select id="fixCategorySelect" required><option value="Fix1">Fix1</option><option value="Fix2">Fix2</option><option value="Fix3">Fix3</option><option value="Fix4">Fix4</option></select>
                    <label for="numRows">Number of Tasks/Rows:</label>
                    <input type="number" id="numRows" value="1" min="1" required>
                    <label for="baseProjectName">Base Project Name:</label>
                    <input type="text" id="baseProjectName" value="PROJ_ID_XYZ" required>
                    <label for="gsd">GSD:</label>
                    <select id="gsd" required><option value="3in">3in</option><option value="9in">9in</option></select>
                    <button type="submit" class="btn btn-success">Add Project(s)</button>
                </form>
            </div>
        </div>

        <div id="tlDashboardModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeTlDashboardBtn">&times;</span>
                <h2>ðŸ‘‘ Team Lead Dashboard</h2>
                <div id="tlDashboardContent"></div>
            </div>
        </div>

        <h3>ðŸ“Œ Project Details</h3>
        <table id="projectTable">
            <thead>
                <tr>
                    <th>Fix</th><th style="min-width: 150px;">Project Name</th><th style="min-width: 80px;">Area</th><th>GSD</th>
                    <th style="min-width: 80px;">Assigned Tech</th><th style="min-width: 120px;">Status</th>
                    <th>D1 Start</th><th>D1 End</th><th>D1 Dur(m)</th>
                    <th>D2 Start</th><th>D2 End</th><th>D2 Dur(m)</th>
                    <th>Total(m)</th><th style="min-width: 120px;">Tech Notes</th><th style="min-width: 150px;">Actions</th>
                </tr>
            </thead>
            <tbody id="projectTableBody"></tbody>
        </table>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script>
        // CRITICAL SECURITY WARNING: Your Firebase API keys are exposed here.
        // For production, secure your data with Firebase Security Rules and restrict API key usage in Google Cloud Console.
        const firebaseConfig = {
          apiKey: "AIzaSyADB1W9YKaU6DFqGyjivsADJOhuIRY0eZ0", // Replace with your actual key
          authDomain: "project-tracker-fddb1.firebaseapp.com",
          projectId: "project-tracker-fddb1",
          storageBucket: "project-tracker-fddb1.firebasestorage.app",
          messagingSenderId: "698282455986",
          appId: "1:698282455986:web:f31fa7830148dc47076aab",
          measurementId: "G-6D2Z9ZWEN1"
        };

        let app;
        let db;

        try {
            if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                throw new Error("Firebase SDK not loaded. Ensure Firebase scripts are correctly included.");
            }
            app = firebase.initializeApp(firebaseConfig);
            if (typeof app.firestore === 'undefined') {
                 throw new Error("Firestore SDK not loaded or initialized correctly with the app.");
            }
            db = firebase.firestore();
            console.log("Firebase initialized successfully!");
        } catch (e) {
            console.error("CRITICAL: Error initializing Firebase: ", e.message);
            alert("CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: " + e.message);
        }

        const DEFAULT_PIN = "1234"; // WARNING: Client-side PIN is not secure.
        const FIX_CATEGORIES_ORDER = ["Fix1", "Fix2", "Fix3", "Fix4"];
        // MODIFIED: Added Reassigned_TechAbsent to STATUS_ORDER
        const STATUS_ORDER = {
            'Available': 1,
            'InProgressDay1': 2,
            'Day1Ended_AwaitingNext': 3,
            'InProgressDay2': 4,
            'Completed': 5,
            'Reassigned_TechAbsent': 6
        };
        const NUM_TABLE_COLUMNS = 15;

        let openAddNewProjectBtn, openTlDashboardBtn, projectFormModal, tlDashboardModal,
            closeProjectFormBtn, closeTlDashboardBtn, newProjectForm, projectTableBody,
            tlDashboardContentElement;

        let projects = [];
        let groupVisibilityState = {};

        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }
        function formatMillisToMinutes(millis) { return (millis === null || typeof millis !== 'number' || millis < 0) ? 'N/A' : Math.floor(millis / 60000); }

        function calculateDurationMs(startTime, endTime) {
            let startMillis = startTime;
            let endMillis = endTime;
            if (startTime && typeof startTime.toMillis === 'function') startMillis = startTime.toMillis();
            if (endTime && typeof endTime.toMillis === 'function') endMillis = endTime.toMillis();
            else if (typeof startTime === 'number' && typeof endTime === 'number') { /* proceed */ }
            else if (startTime && typeof startTime.toMillis === 'function' && typeof endTime === 'number') { /* endMillis is already a number */ }
            else if (typeof startTime === 'number' && endTime && typeof endTime.toMillis === 'function') { /* startMillis is already a number */ }
            else {
                 if (!startTime || !endTime) return null;
                 if (typeof startTime !== 'number' && !isNaN(new Date(startTime).getTime())) startMillis = new Date(startTime).getTime();
                 if (typeof endTime !== 'number' && !isNaN(new Date(endTime).getTime())) endMillis = new Date(endTime).getTime();
            }
            return (!startMillis || !endMillis || endMillis < startMillis || isNaN(startMillis) || isNaN(endMillis)) ? null : endMillis - startMillis;
        }

        function loadGroupVisibilityState() {
            try {
                const savedState = localStorage.getItem('projectTrackerGroupVisibility');
                if (savedState) {
                    groupVisibilityState = JSON.parse(savedState);
                } else {
                    groupVisibilityState = {};
                }
            } catch (e) {
                console.error("Error parsing group visibility state from localStorage:", e);
                groupVisibilityState = {};
            }
        }

        function saveGroupVisibilityState() {
            try {
                localStorage.setItem('projectTrackerGroupVisibility', JSON.stringify(groupVisibilityState));
            } catch (lsError) {
                console.error("Error saving group visibility state to localStorage:", lsError);
                alert("Warning: Could not save your group visibility preferences.");
            }
        }

        function initializeFirebaseAndLoadData() {
            if (!db) {
                console.error("Firestore (db) not initialized. Cannot load data.");
                alert("ERROR: Database connection failed. App cannot load data.");
                projects = []; refreshAllViews(); return;
            }
            loadGroupVisibilityState();
            try {
                db.collection("projects").orderBy("batchId").orderBy("fixCategory").orderBy("areaTask") // Consider adding .orderBy("creationTimestamp") for reassigned tasks order
                  .onSnapshot((querySnapshot) => {
                    const firebaseProjects = [];
                    querySnapshot.forEach((doc) => {
                        if (doc.exists && typeof doc.data === 'function') {
                            firebaseProjects.push({ id: doc.id, ...doc.data() });
                        }
                    });
                    projects = firebaseProjects;
                    projects.forEach(p => {
                        if (p && p.batchId && p.fixCategory) {
                            const groupStateKey = `${p.batchId}_${p.fixCategory}`;
                            if (groupVisibilityState[groupStateKey] === undefined) {
                                groupVisibilityState[groupStateKey] = { isExpanded: true };
                            }
                        }
                    });
                    refreshAllViews();
                }, (error) => {
                    console.error("Error fetching projects from Firebase (onSnapshot): ", error);
                    alert("Error fetching projects. Check console. Error: " + error.message);
                    projects = []; refreshAllViews();
                });
            } catch (fbError) {
                 console.error("CRITICAL Error setting up Firebase listener: ", fbError);
                 alert("A critical error occurred while listening for project updates. Error: " + fbError.message);
            }
        }

        function setupDOMReferences() {
            openAddNewProjectBtn = document.getElementById('openAddNewProjectBtn');
            openTlDashboardBtn = document.getElementById('openTlDashboardBtn');
            projectFormModal = document.getElementById('projectFormModal');
            tlDashboardModal = document.getElementById('tlDashboardModal');
            closeProjectFormBtn = document.getElementById('closeProjectFormBtn');
            closeTlDashboardBtn = document.getElementById('closeTlDashboardBtn');
            newProjectForm = document.getElementById('newProjectForm');
            projectTableBody = document.getElementById('projectTableBody');
            tlDashboardContentElement = document.getElementById('tlDashboardContent');
            if (!openAddNewProjectBtn || !newProjectForm || !projectTableBody || !tlDashboardContentElement || !projectFormModal || !tlDashboardModal) {
                 console.error("CRITICAL DOM ERROR: One or more essential elements not found!");
            }
        }

        function attachEventListeners() {
            if (openAddNewProjectBtn) {
                openAddNewProjectBtn.onclick = () => {
                    if (projectFormModal) projectFormModal.style.display = 'block';
                    else console.error("Cannot open Add Project modal: projectFormModal is null.");
                };
            }
            if (closeProjectFormBtn) closeProjectFormBtn.onclick = () => { if (projectFormModal) projectFormModal.style.display = 'none'; };
            if (openTlDashboardBtn) {
                openTlDashboardBtn.onclick = () => {
                    const pin = prompt("Enter PIN to access TL Dashboard:", "");
                    if (pin === DEFAULT_PIN) {
                        if (tlDashboardModal) { tlDashboardModal.style.display = 'block'; renderTLDashboard(); }
                        else console.error("Cannot open TL Dashboard: tlDashboardModal is null.");
                    } else if (pin !== null) alert("Incorrect PIN.");
                };
            }
            if (closeTlDashboardBtn) closeTlDashboardBtn.onclick = () => { if (tlDashboardModal) tlDashboardModal.style.display = 'none'; };
            if (typeof window !== 'undefined') {
                window.onclick = (event) => {
                    if (projectFormModal && event.target == projectFormModal) projectFormModal.style.display = 'none';
                    if (tlDashboardModal && event.target == tlDashboardModal) tlDashboardModal.style.display = 'none';
                };
            }
            if (newProjectForm) newProjectForm.addEventListener('submit', handleAddProjectSubmit);
            else console.error("Cannot attach submit listener: newProjectForm not found.");
        }

        async function handleAddProjectSubmit(e) {
            e.preventDefault();
            if (!db) { alert("CRITICAL: Database not initialized! Cannot add projects."); return; }
            const fixCategoryElement = document.getElementById('fixCategorySelect');
            const numRowsElement = document.getElementById('numRows');
            const baseProjectNameElement = document.getElementById('baseProjectName');
            const gsdElement = document.getElementById('gsd');
            if (!fixCategoryElement || !numRowsElement || !baseProjectNameElement || !gsdElement) {
                alert("Error: Form elements missing. Could not submit."); return;
            }
            const fixCategory = fixCategoryElement.value;
            const numRows = parseInt(numRowsElement.value, 10);
            const baseProjectNameVal = baseProjectNameElement.value.trim();
            const gsd = gsdElement.value;
            if (!baseProjectNameVal) { alert("Base Project Name cannot be empty."); return; }
            if (isNaN(numRows) || numRows < 1) { alert("Number of Tasks must be a positive number."); return; }

            const currentBatchId = "batch_" + generateId();
            const batchCreationTimestamp = firebase.firestore.FieldValue.serverTimestamp();
            const fbBatch = db.batch();
            try {
                for (let i = 1; i <= numRows; i++) {
                    const currentAreaTask = `Area${String(i).padStart(2, '0')}`;
                    const newProjectData = {
                        batchId: currentBatchId, creationTimestamp: batchCreationTimestamp,
                        fixCategory: fixCategory, baseProjectName: baseProjectNameVal,
                        areaTask: currentAreaTask, gsd: gsd, assignedTo: "", techNotes: "", status: 'Available',
                        startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null,
                        startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                        releasedToNextStage: false, lastModifiedTimestamp: batchCreationTimestamp,
                        isReassigned: false, originalProjectId: null // ADDED for new re-assign logic
                    };
                    const docRef = db.collection("projects").doc();
                    fbBatch.set(docRef, newProjectData);
                }
                await fbBatch.commit();
                if (newProjectForm) newProjectForm.reset();
            } catch (error) {
                console.error("Error adding projects to Firebase: ", error);
                alert("Error adding projects. Error: " + error.message);
            } finally {
                if (projectFormModal) projectFormModal.style.display = 'none';
            }
        }

        function getManageableBatches() { /* ... (previous robust version) ... */
            const allBatchesInfo = {};
            projects.forEach(p => {
                if (p && p.batchId) {
                    if (!allBatchesInfo[p.batchId]) {
                        allBatchesInfo[p.batchId] = { batchId: p.batchId, baseProjectName: p.baseProjectName || "N/A", tasksByFix: {} };
                    }
                    if (p.fixCategory && !allBatchesInfo[p.batchId].tasksByFix[p.fixCategory]) {
                        allBatchesInfo[p.batchId].tasksByFix[p.fixCategory] = [];
                    }
                    if (p.fixCategory) {
                        allBatchesInfo[p.batchId].tasksByFix[p.fixCategory].push(p);
                    }
                }
            });
            return Object.values(allBatchesInfo);
        }

        function renderTLDashboard() { /* ... (previous robust version) ... */
            if (!tlDashboardContentElement) { console.error("tlDashboardContentElement not found."); return; }
            tlDashboardContentElement.innerHTML = '';
            const manageableBatches = getManageableBatches();
            if (manageableBatches.length === 0) {
                tlDashboardContentElement.innerHTML = '<p>No project batches found.</p>'; return;
            }
            manageableBatches.forEach(batch => {
                if (!batch || !batch.batchId) return;
                const batchDiv = document.createElement('div'); batchDiv.classList.add('dashboard-batch-item');
                const title = document.createElement('h4'); title.textContent = `Batch: ${batch.baseProjectName || 'Unknown'} (ID: ${batch.batchId.split('_')[1] || 'N/A'})`; batchDiv.appendChild(title);
                const stagesPresentP = document.createElement('p');
                const presentFixCategories = batch.tasksByFix ? Object.keys(batch.tasksByFix).sort((a,b) => FIX_CATEGORIES_ORDER.indexOf(a) - FIX_CATEGORIES_ORDER.indexOf(b)) : [];
                stagesPresentP.innerHTML = `<strong>Stages Present:</strong> ${presentFixCategories.join(', ') || 'None'}`; batchDiv.appendChild(stagesPresentP);
                const releaseActionsDiv = document.createElement('div'); releaseActionsDiv.classList.add('dashboard-batch-actions-release');
                let latestFixCategoryForBatch = ""; let allTasksInLatestStageReadyForRelease = false; let alreadyReleasedFromLatestStage = true;
                if (batch.tasksByFix) {
                    FIX_CATEGORIES_ORDER.slice().reverse().forEach(fixCat => {
                        if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0 && !latestFixCategoryForBatch) {
                            latestFixCategoryForBatch = fixCat;
                            alreadyReleasedFromLatestStage = batch.tasksByFix[fixCat].every(t => t && t.releasedToNextStage && t.status !== 'Reassigned_TechAbsent'); // Original, active tasks
                            if (!alreadyReleasedFromLatestStage) {
                                allTasksInLatestStageReadyForRelease = batch.tasksByFix[fixCat].filter(t => t.status !== 'Reassigned_TechAbsent').every(t => t && (t.status === 'Completed' || t.status === 'Day1Ended_AwaitingNext'));
                            }
                        }
                    });
                }
                if (latestFixCategoryForBatch && !alreadyReleasedFromLatestStage) {
                    const currentFixIdx = FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch);
                    if (currentFixIdx < FIX_CATEGORIES_ORDER.length - 1) {
                        const nextFixCategory = FIX_CATEGORIES_ORDER[currentFixIdx + 1];
                        const releaseBtn = document.createElement('button'); releaseBtn.textContent = `Release to ${nextFixCategory}`; releaseBtn.classList.add('btn', 'btn-release');
                        if (!allTasksInLatestStageReadyForRelease) {
                            releaseBtn.disabled = true; releaseBtn.title = `Not all active tasks in ${latestFixCategoryForBatch} are 'Completed' or 'Day 1 Ended'.`;
                        }
                        releaseBtn.onclick = () => releaseBatchToNextFix(batch.batchId, latestFixCategoryForBatch, nextFixCategory);
                        releaseActionsDiv.appendChild(releaseBtn);
                    }
                } else if (alreadyReleasedFromLatestStage && latestFixCategoryForBatch && FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch) < FIX_CATEGORIES_ORDER.length -1) {
                    const releasedInfoP = document.createElement('p'); releasedInfoP.innerHTML = `<small><em>(Active tasks released from ${latestFixCategoryForBatch})</em></small>`; releaseActionsDiv.appendChild(releasedInfoP);
                }
                batchDiv.appendChild(releaseActionsDiv);
                const deleteActionsDiv = document.createElement('div'); deleteActionsDiv.classList.add('dashboard-batch-actions-delete');
                if (batch.tasksByFix) {
                    FIX_CATEGORIES_ORDER.forEach(fixCat => {
                        if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0) {
                            const deleteFixBtn = document.createElement('button'); deleteFixBtn.textContent = `Delete ${fixCat} Tasks`; deleteFixBtn.classList.add('btn', 'btn-danger');
                            deleteFixBtn.onclick = () => { if (confirm(`Are you sure you want to delete all ${fixCat} tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteSpecificFixTasksForBatch(batch.batchId, fixCat); };
                            deleteActionsDiv.appendChild(deleteFixBtn);
                        }
                    });
                }
                const deleteAllBtn = document.createElement('button'); deleteAllBtn.textContent = 'Delete ALL Tasks for this Batch'; deleteAllBtn.classList.add('btn', 'btn-danger');
                deleteAllBtn.onclick = () => { if (confirm(`Are you sure you want to delete ALL tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteProjectBatch(batch.batchId); };
                deleteActionsDiv.appendChild(deleteAllBtn); batchDiv.appendChild(deleteActionsDiv); tlDashboardContentElement.appendChild(batchDiv);
            });
        }

        async function releaseBatchToNextFix(batchId, currentFixCategory, nextFixCategory) { /* ... (previous robust version, ensure it considers 'Reassigned_TechAbsent' status if necessary for logic) ... */
            if (!db) { alert("Database not initialized!"); return; }
            if (!batchId || !currentFixCategory || !nextFixCategory) { alert("Error: Missing info to release batch."); return; }
            try {
                const sourceTasksSnapshot = await db.collection("projects")
                    .where("batchId", "==", batchId)
                    .where("fixCategory", "==", currentFixCategory)
                    .where("releasedToNextStage", "==", false)
                    // MODIFICATION: Ensure we only consider tasks that are not already reassigned originals
                    // .where("status", "!=", "Reassigned_TechAbsent") // This query is not supported directly. Filter client-side.
                    .get();

                if (sourceTasksSnapshot.empty) {
                    alert("No active tasks found for this batch in the current stage to release, or they may have already been released.");
                    refreshAllViews(); return;
                }

                const sourceBatchTasks = [];
                sourceTasksSnapshot.forEach(doc => {
                    const data = doc.data();
                    // Client-side filter for tasks that aren't just placeholders for reassignment
                    if (data.status !== 'Reassigned_TechAbsent') {
                        sourceBatchTasks.push({id: doc.id, ...data });
                    }
                });

                if (sourceBatchTasks.length === 0) {
                     alert("No active tasks found for this batch in the current stage to release after filtering.");
                     refreshAllViews(); return;
                }


                const allReadyForRelease = sourceBatchTasks.every(p => p && (p.status === 'Completed' || p.status === 'Day1Ended_AwaitingNext'));
                if (!allReadyForRelease) {
                    alert(`Not all active tasks in batch ID ${batchId} for ${currentFixCategory} are 'Completed' or 'Day 1 Ended'. Cannot release.`);
                    return;
                }

                const releaseTimestamp = firebase.firestore.FieldValue.serverTimestamp();
                const fbBatch = db.batch();

                for (const sourceTask of sourceBatchTasks) {
                    if (!sourceTask || !sourceTask.id) continue;

                    const q = db.collection("projects")
                        .where("batchId", "==", sourceTask.batchId)
                        .where("areaTask", "==", sourceTask.areaTask) // This might create duplicates if original also has same areaTask. Consider unique ID for next stage task.
                        .where("fixCategory", "==", nextFixCategory);
                    const existingNextStageTaskSnapshot = await q.get();
                    let newDocCreated = false;

                    if (existingNextStageTaskSnapshot.empty) { // Only create if no task for this Area/Task exists in the next fix yet
                        const newTaskData = {
                            batchId: sourceTask.batchId, creationTimestamp: sourceTask.creationTimestamp, // Keep original creation for batch context
                            fixCategory: nextFixCategory, baseProjectName: sourceTask.baseProjectName,
                            areaTask: sourceTask.areaTask, gsd: sourceTask.gsd,
                            assignedTo: sourceTask.assignedTo, techNotes: "", status: 'Available',
                            startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null,
                            startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                            releasedToNextStage: false, lastModifiedTimestamp: releaseTimestamp,
                            isReassigned: false, // This is a new stage, not a direct reassignment of this instance
                            originalProjectId: sourceTask.id // Link to previous stage task
                        };
                        const newDocRef = db.collection("projects").doc();
                        fbBatch.set(newDocRef, newTaskData);
                        newDocCreated = true;
                    } else {
                        // If it exists, should we update it? Or assume it's already handled?
                        // For now, if it exists, we just mark the current one as released.
                        // This logic might need refinement based on exact workflow for existing next-stage tasks.
                        console.log(`Task for ${sourceTask.areaTask} in ${nextFixCategory} already exists. Marking current as released.`);
                    }

                    const sourceDocRef = db.collection("projects").doc(sourceTask.id);
                    fbBatch.update(sourceDocRef, { releasedToNextStage: true, lastModifiedTimestamp: releaseTimestamp });
                }
                await fbBatch.commit();
                console.log(`Batch ${batchId} (${currentFixCategory}) active tasks processed for release to ${nextFixCategory}.`);
            } catch (error) {
                console.error("Error releasing batch to Firebase:", error);
                alert("Error releasing batch. Error: " + error.message);
            }
        }


        async function deleteProjectBatch(batchIdToDelete) { /* ... (previous robust version) ... */
            if (!db) { alert("Database not initialized!"); return; }
            if (!batchIdToDelete) { alert("Error: No Batch ID provided for deletion."); return; }
            try {
                const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).get();
                if (querySnapshot.empty) { console.log(`No projects for batch ${batchIdToDelete} to delete.`); return; }
                const fbBatch = db.batch();
                querySnapshot.forEach(doc => fbBatch.delete(doc.ref));
                await fbBatch.commit();
                console.log(`Batch ${batchIdToDelete} deleted.`);
            } catch (error) {
                console.error(`Error deleting batch ${batchIdToDelete}:`, error);
                alert("Error deleting batch. Error: " + error.message);
            }
        }

        async function deleteSpecificFixTasksForBatch(batchIdToDelete, fixCategoryToDelete) { /* ... (previous robust version) ... */
            if (!db) { alert("Database not initialized!"); return; }
            if (!batchIdToDelete || !fixCategoryToDelete) { alert("Error: Missing Batch ID or Fix Category."); return; }
            try {
                const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).where("fixCategory", "==", fixCategoryToDelete).get();
                if (querySnapshot.empty) { console.log(`No ${fixCategoryToDelete} tasks for batch ${batchIdToDelete} to delete.`); return; }
                const fbBatch = db.batch();
                querySnapshot.forEach(doc => fbBatch.delete(doc.ref));
                await fbBatch.commit();
                console.log(`${fixCategoryToDelete} tasks for batch ${batchIdToDelete} deleted.`);
            } catch (error) {
                console.error(`Error deleting ${fixCategoryToDelete} for batch ${batchIdToDelete}:`, error);
                alert("Error deleting specific fix tasks. Error: " + error.message);
            }
        }

        function renderProjects() {
            if (!projectTableBody) { console.error("CRITICAL: projectTableBody not found."); return; }
            projectTableBody.innerHTML = '';
            const projectsToRender = [...projects];
            try { // Robust sort
                projectsToRender.sort((a, b) => {
                    if (!a || !b) return 0;
                    if ((a.batchId || "") < (b.batchId || "")) return -1;
                    if ((a.batchId || "") > (b.batchId || "")) return 1;
                    const fixOrderA = FIX_CATEGORIES_ORDER.indexOf(a.fixCategory || "");
                    const fixOrderB = FIX_CATEGORIES_ORDER.indexOf(b.fixCategory || "");
                    if (fixOrderA < fixOrderB) return -1; if (fixOrderA > fixOrderB) return 1;
                    if ((a.areaTask || "") < (b.areaTask || "")) return -1;
                    if ((a.areaTask || "") > (b.areaTask || "")) return 1;
                    // MODIFIED: If areaTask is the same (reassignment), sort by creationTimestamp (newest reassignment first)
                    if ((a.areaTask || "") === (b.areaTask || "")) {
                        let tsA_create = a.creationTimestamp; let tsB_create = b.creationTimestamp;
                        if (tsA_create && typeof tsA_create.toMillis === 'function') tsA_create = tsA_create.toMillis();
                        if (tsB_create && typeof tsB_create.toMillis === 'function') tsB_create = tsB_create.toMillis();
                        tsA_create = typeof tsA_create === 'number' ? tsA_create : 0;
                        tsB_create = typeof tsB_create === 'number' ? tsB_create : 0;
                        if (tsA_create > tsB_create) return -1; // newest first
                        if (tsA_create < tsB_create) return 1;
                    }
                    const statusAVal = STATUS_ORDER[a.status || ""] || 99;
                    const statusBVal = STATUS_ORDER[b.status || ""] || 99;
                    if (statusAVal < statusBVal) return -1; if (statusAVal > statusBVal) return 1;
                    return 0;
                });
            } catch(sortError) { console.error("Error during project sort:", sortError); }

            let currentBatchIdForDisplay = null; let currentFixCategoryForHeader = null;
            projectsToRender.forEach(project => {
                if (!project || !project.id || !project.batchId || !project.fixCategory) {
                    console.warn("Skipping malformed project:", project); return;
                }
                if (project.batchId !== currentBatchIdForDisplay) {
                    if (currentBatchIdForDisplay !== null) { /* separator row */ }
                    currentBatchIdForDisplay = project.batchId; currentFixCategoryForHeader = null;
                    const batchHeaderRow = projectTableBody.insertRow(); batchHeaderRow.classList.add('batch-header-row');
                    const batchHeaderCell = batchHeaderRow.insertCell(); batchHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString());
                    batchHeaderCell.textContent = `Project Batch: ${project.baseProjectName || 'Unknown'} (ID: ${project.batchId.split('_')[1] || 'N/A'})`;
                }
                if (project.fixCategory !== currentFixCategoryForHeader) {
                    currentFixCategoryForHeader = project.fixCategory;
                    const groupStateKey = `${project.batchId}_${currentFixCategoryForHeader}`;
                    if (groupVisibilityState[groupStateKey] === undefined) groupVisibilityState[groupStateKey] = { isExpanded: true };
                    const groupHeaderRow = projectTableBody.insertRow(); groupHeaderRow.classList.add('fix-group-header');
                    const groupHeaderCell = groupHeaderRow.insertCell(); groupHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString());
                    const toggleBtn = document.createElement('button'); toggleBtn.classList.add('btn', 'btn-group-toggle');
                    const isExpanded = groupVisibilityState[groupStateKey]?.isExpanded !== false;
                    toggleBtn.textContent = isExpanded ? 'âˆ’' : '+';
                    toggleBtn.title = isExpanded ? `Collapse ${currentFixCategoryForHeader}` : `Expand ${currentFixCategoryForHeader}`;
                    groupHeaderCell.appendChild(document.createTextNode(`${currentFixCategoryForHeader} `));
                    groupHeaderCell.appendChild(toggleBtn);
                    groupHeaderCell.onclick = (e) => {
                        if (e.target === toggleBtn || e.target === groupHeaderCell || groupHeaderCell.contains(e.target)) {
                            if (groupVisibilityState[groupStateKey]) {
                                groupVisibilityState[groupStateKey].isExpanded = !groupVisibilityState[groupStateKey].isExpanded;
                                saveGroupVisibilityState(); renderProjects();
                            }
                        }
                    };
                }

                const row = projectTableBody.insertRow();
                const currentGroupStateKeyForRow = `${project.batchId}_${project.fixCategory}`;
                if (!(groupVisibilityState[currentGroupStateKeyForRow]?.isExpanded !== false)) {
                    row.classList.add('hidden-group-row');
                }

                // Apply base fix color class first
                if (project.fixCategory) {
                    row.classList.add(`${project.fixCategory.toLowerCase()}-row`);
                }
                // If reassigned, add the highlight class
                if (project.isReassigned) {
                    row.classList.add('reassigned-task-highlight');
                }

                row.insertCell().textContent = project.fixCategory || 'N/A';
                const baseNameCell = row.insertCell(); baseNameCell.textContent = project.baseProjectName || 'N/A'; baseNameCell.classList.add('wrap-text');
                row.insertCell().textContent = project.areaTask || 'N/A';
                row.insertCell().textContent = project.gsd || 'N/A';

                const assignedToCell = row.insertCell(); const assignedToInput = document.createElement('input');
                assignedToInput.type = 'text'; assignedToInput.value = project.assignedTo || '';
                assignedToInput.placeholder = 'ID'; assignedToInput.classList.add('assigned-to-input');
                // MODIFICATION: Disable assignedTo input if original task is reassigned
                assignedToInput.disabled = project.status === 'Reassigned_TechAbsent';
                assignedToInput.onchange = async (event) => { /* ... (previous robust onchange) ... */
                    const newVal = event.target.value.trim();
                    if (!db || !project.id) { alert("Error: Cannot save. DB or ID missing."); event.target.value = project.assignedTo || ''; return; }
                    try {
                        await db.collection("projects").doc(project.id).update({ assignedTo: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() });
                    } catch (error) { console.error("Error updating assignedTo:", error); alert("Error saving 'Assigned To'. Error: " + error.message); event.target.value = project.assignedTo || ''; }
                };
                assignedToCell.appendChild(assignedToInput);

                const statusCell = row.insertCell(); const statusSpan = document.createElement('span');
                statusSpan.classList.add('status');
                let statusText = (project.status || "Unknown").replace(/([A-Z])(?=[a-z0-9_])/g, ' $1').trim();
                if (project.status === "Day1Ended_AwaitingNext") statusText = "Started Available";
                if (project.status === "Reassigned_TechAbsent") statusText = "Re-Assigned"; // Display text
                statusSpan.textContent = statusText;
                statusSpan.classList.add(`status-${(project.status || "unknown").toLowerCase()}`);
                statusCell.appendChild(statusSpan);

                const timeFormatOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
                let d1s = project.startTimeDay1, d1f = project.finishTimeDay1, d2s = project.startTimeDay2, d2f = project.finishTimeDay2;
                try { /* ... (previous robust date parsing) ... */
                    if (d1s && typeof d1s.toDate === 'function') d1s = d1s.toDate(); else if (d1s) d1s = new Date(d1s); else d1s = null;
                    if (d1f && typeof d1f.toDate === 'function') d1f = d1f.toDate(); else if (d1f) d1f = new Date(d1f); else d1f = null;
                    if (d2s && typeof d2s.toDate === 'function') d2s = d2s.toDate(); else if (d2s) d2s = new Date(d2s); else d2s = null;
                    if (d2f && typeof d2f.toDate === 'function') d2f = d2f.toDate(); else if (d2f) d2f = new Date(d2f); else d2f = null;
                } catch (dateError) { console.error("Error parsing date for " + project.id, dateError); d1s = d1f = d2s = d2f = null; }
                row.insertCell().textContent = d1s && !isNaN(d1s) ? d1s.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d1f && !isNaN(d1f) ? d1f.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = formatMillisToMinutes(project.durationDay1Ms);
                row.insertCell().textContent = d2s && !isNaN(d2s) ? d2s.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = d2f && !isNaN(d2f) ? d2f.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                row.insertCell().textContent = formatMillisToMinutes(project.durationDay2Ms);
                row.insertCell().textContent = formatMillisToMinutes((project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) > 0 ? (project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) : null);

                const techNotesCell = row.insertCell(); const techNotesInput = document.createElement('textarea');
                techNotesInput.value = project.techNotes || ''; techNotesInput.placeholder = 'Notes';
                techNotesInput.classList.add('tech-notes-input'); techNotesInput.rows = 1;
                techNotesInput.id = `techNotes_${project.id}`;
                 // MODIFICATION: Disable techNotes input if original task is reassigned
                techNotesInput.disabled = project.status === 'Reassigned_TechAbsent';
                techNotesInput.onchange = async (event) => { /* ... (previous robust onchange) ... */
                    const newVal = event.target.value;
                    if (!db || !project.id) { alert("Error: Cannot save. DB or ID missing."); event.target.value = project.techNotes || ''; return; }
                    try {
                        await db.collection("projects").doc(project.id).update({ techNotes: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() });
                    } catch (error) { console.error("Error updating techNotes:", error); alert("Error saving Tech Notes. Error: " + error.message); event.target.value = project.techNotes || ''; }
                };
                techNotesCell.appendChild(techNotesInput);

                const actionsCell = row.insertCell(); const btnContainer = document.createElement('div');
                const isOriginalReassignedTask = project.status === 'Reassigned_TechAbsent';

                const sD1btn = document.createElement('button'); sD1btn.textContent = 'Start D1'; sD1btn.classList.add('btn','btn-day-start');
                sD1btn.disabled = project.status !== 'Available' || isOriginalReassignedTask;
                sD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay1'); }; btnContainer.appendChild(sD1btn);

                const eD1btn = document.createElement('button'); eD1btn.textContent = 'End D1'; eD1btn.classList.add('btn','btn-day-end');
                eD1btn.disabled = project.status !== 'InProgressDay1' || isOriginalReassignedTask;
                eD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay1'); }; btnContainer.appendChild(eD1btn);

                const sD2btn = document.createElement('button'); sD2btn.textContent = 'Start D2'; sD2btn.classList.add('btn','btn-day-start');
                sD2btn.disabled = project.status !== 'Day1Ended_AwaitingNext' || isOriginalReassignedTask;
                sD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay2'); }; btnContainer.appendChild(sD2btn);

                const eD2btn = document.createElement('button'); eD2btn.textContent = 'End D2'; eD2btn.classList.add('btn','btn-day-end');
                eD2btn.disabled = project.status !== 'InProgressDay2' || isOriginalReassignedTask;
                eD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay2'); }; btnContainer.appendChild(eD2btn);

                const doneBtn = document.createElement('button'); doneBtn.textContent = 'Done'; doneBtn.classList.add('btn','btn-mark-done');
                doneBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask;
                doneBtn.onclick = () => { if (project.id) updateProjectState(project.id, 'markDone'); }; btnContainer.appendChild(doneBtn);

                const reassignBtn = document.createElement('button'); reassignBtn.textContent = 'Re-Assign';
                reassignBtn.classList.add('btn', 'btn-warning'); reassignBtn.title = 'Re-assign task by creating a new entry.';
                reassignBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; // Can't re-assign a completed or already 'closed' original
                reassignBtn.onclick = () => {
                    const currentProjectData = projects.find(p => p.id === project.id); // Get fresh data
                    if (currentProjectData) handleReassignment(currentProjectData); // Pass the whole object
                    else alert("Error: Could not retrieve task data for re-assignment.");
                };
                btnContainer.appendChild(reassignBtn);
                actionsCell.appendChild(btnContainer);
            });
        }

        async function updateProjectState(projectId, action) { /* ... (previous robust version, check for currentProjectData.status !== 'Reassigned_TechAbsent' before allowing updates) ... */
            if (!db) { alert("Database not initialized!"); return; }
            if (!projectId) { alert("Error: Project ID missing."); return; }
            const projectRef = db.collection("projects").doc(projectId);
            let currentProjectData;
            try {
                const doc = await projectRef.get();
                if (!doc.exists) { alert(`Error: Project ${projectId} not found.`); return; }
                currentProjectData = doc.data();
            } catch(error) { console.error("Error fetching project:", error); alert("Error fetching project. Error: " + error.message); return; }

            if (!currentProjectData) { alert(`Error: Could not get data for project ${projectId}.`); return; }

            // ADDED: Prevent updates on tasks marked as 'Reassigned_TechAbsent' except by specific admin functions
            if (currentProjectData.status === 'Reassigned_TechAbsent') {
                alert("This task instance was re-assigned and is closed. No further status changes allowed on this instance.");
                return;
            }

            const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp();
            const clientNowMillis = Date.now();
            let updatedFields = { lastModifiedTimestamp: serverTimestamp };

            switch (action) {
                case 'startDay1':
                    if (currentProjectData.status === 'Available') updatedFields = { ...updatedFields, status: 'InProgressDay1', startTimeDay1: serverTimestamp, finishTimeDay1: null, durationDay1Ms: null, startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null };
                    else console.warn(`Cannot 'startDay1'. Status: ${currentProjectData.status}`); break;
                case 'endDay1':
                    if (currentProjectData.status === 'InProgressDay1' && currentProjectData.startTimeDay1) updatedFields = { ...updatedFields, status: 'Day1Ended_AwaitingNext', finishTimeDay1: serverTimestamp, durationDay1Ms: calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis) };
                    else console.warn(`Cannot 'endDay1'. Status: ${currentProjectData.status}`); break;
                case 'startDay2':
                    if (currentProjectData.status === 'Day1Ended_AwaitingNext') updatedFields = { ...updatedFields, status: 'InProgressDay2', startTimeDay2: serverTimestamp, finishTimeDay2: null, durationDay2Ms: null };
                    else console.warn(`Cannot 'startDay2'. Status: ${currentProjectData.status}`); break;
                case 'endDay2':
                    if (currentProjectData.status === 'InProgressDay2' && currentProjectData.startTimeDay2) updatedFields = { ...updatedFields, status: 'Completed', finishTimeDay2: serverTimestamp, durationDay2Ms: calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis) };
                    else console.warn(`Cannot 'endDay2'. Status: ${currentProjectData.status}`); break;
                case 'markDone':
                    if (currentProjectData.status !== 'Completed') {
                        updatedFields.status = 'Completed';
                        if (currentProjectData.startTimeDay1 && !currentProjectData.finishTimeDay1) { updatedFields.finishTimeDay1 = serverTimestamp; updatedFields.durationDay1Ms = calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis); }
                        if (currentProjectData.startTimeDay2 && !currentProjectData.finishTimeDay2) { updatedFields.finishTimeDay2 = serverTimestamp; updatedFields.durationDay2Ms = calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis); }
                        // If only Day 1 was done, and no Day 2 started, ensure Day 2 duration remains null.
                        if (!currentProjectData.startTimeDay2) { updatedFields.durationDay2Ms = null; updatedFields.finishTimeDay2 = null; }
                    } else console.warn(`Cannot 'markDone'. Status: ${currentProjectData.status}`); break;
                default: console.log("Unknown action:", action); return;
            }

            if (Object.keys(updatedFields).length > 1) {
                try { await projectRef.update(updatedFields); console.log(`Project ${projectId} action ${action} updated.`); }
                catch (error) { console.error(`Error updating project ${projectId}:`, error); alert(`Error updating project. Error: ${error.message}`); }
            } else console.log(`No fields to update for ${action} on ${projectId}. Status: ${currentProjectData.status}`);
        }

        async function handleReassignment(originalProjectData) {
            if (!originalProjectData || !originalProjectData.id) {
                alert("Cannot re-assign: Original task data is missing."); return;
            }
            if (originalProjectData.status === 'Reassigned_TechAbsent') {
                alert("This task instance has already been re-assigned. You can re-assign the newly created active task if needed."); return;
            }
            if (originalProjectData.status === 'Completed') {
                alert("Cannot re-assign a completed task."); return;
            }

            const currentTechId = originalProjectData.assignedTo || "N/A";
            const newTechId = prompt(`Task for '${originalProjectData.areaTask}' is currently assigned to '${currentTechId}'.\nEnter New Technician ID for the NEW re-assigned task entry:`);

            if (newTechId === null) { console.log("Re-assignment cancelled."); return; }
            const trimmedNewTechId = newTechId.trim();
            if (trimmedNewTechId === "") { alert("New Technician ID cannot be empty."); return; }

            const confirmation = confirm(
                `Create a NEW task entry for '${trimmedNewTechId}' based on Area/Task '${originalProjectData.areaTask}' (from '${currentTechId}')?\n\n` +
                `The current task row for '${currentTechId}' will be marked 'Re-Assigned' and closed.\n` +
                `The new task row will have a distinct highlight and fresh time tracking.`
            );

            if (confirmation) {
                if (!db) { alert("CRITICAL: Database not initialized!"); return; }
                const batch = db.batch();
                const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp();

                const newProjectEntryData = {
                    // Copy relevant fields, DO NOT copy original ID or time/status fields
                    batchId: originalProjectData.batchId,
                    baseProjectName: originalProjectData.baseProjectName,
                    areaTask: originalProjectData.areaTask, // Keep same Area/Task to show relation
                    gsd: originalProjectData.gsd,
                    fixCategory: originalProjectData.fixCategory,
                    // New assignment details
                    assignedTo: trimmedNewTechId,
                    status: 'Available',
                    startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null,
                    startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null,
                    techNotes: ``,
                    creationTimestamp: serverTimestamp, // This is a new entry
                    lastModifiedTimestamp: serverTimestamp,
                    isReassigned: true,
                    originalProjectId: originalProjectData.id, // Link to original task
                    releasedToNextStage: false
                };
                const newProjectRef = db.collection("projects").doc(); // Auto-generate ID
                batch.set(newProjectRef, newProjectEntryData);

                const originalProjectRef = db.collection("projects").doc(originalProjectData.id);
                const originalTaskUpdateData = {
                    status: 'Reassigned_TechAbsent',
                    techNotes: (originalProjectData.techNotes || "") + `\n--- THIS TASK INSTANCE WAS RE-ASSIGNED to '${trimmedNewTechId}' on ${new Date().toLocaleString()}. This instance is now closed. New task ID: ${newProjectRef.id} ---`,
                    lastModifiedTimestamp: serverTimestamp
                };
                batch.update(originalProjectRef, originalTaskUpdateData);

                try {
                    await batch.commit();
                    console.log(`Task ${originalProjectData.id} marked re-assigned. New task ${newProjectRef.id} created for ${trimmedNewTechId}.`);
                } catch (error) {
                    console.error(`Error in batch re-assignment for ${originalProjectData.id}:`, error);
                    alert(`Error re-assigning task. Error: ${error.message}`);
                }
            }
        }

        function refreshAllViews() {
            try {
                renderProjects();
                if (tlDashboardModal && tlDashboardModal.style.display === 'block') { renderTLDashboard(); }
            } catch (e) { console.error("Error during refreshAllViews:", e); alert("Error refreshing view. Error: " + e.message); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");
            try {
                setupDOMReferences();
                if (db) { initializeFirebaseAndLoadData(); }
                else {
                    console.error("Firebase DB not available. App functionality limited.");
                    alert("Firebase did not initialize correctly. App functionality severely limited.");
                    const container = document.querySelector('.container');
                    if (container) {
                        const errorDiv = document.createElement('div');
                        errorDiv.innerHTML = '<h2 style="color:red;">CRITICAL ERROR: DATABASE CONNECTION FAILED.</h2>';
                        container.prepend(errorDiv);
                    }
                }
                attachEventListeners();
            } catch (initError) { console.error("Error during DOMContentLoaded sequence:", initError); alert("Critical error on startup. Error: " + initError.message); }
        });
    </script>
</body>
</html>
