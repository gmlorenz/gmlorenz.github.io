<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team123 - Project Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f7f6; color: #333; line-height: 1.4; }
        .container { width: 98%; max-width: 1900px; margin: 10px auto; padding: 10px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 5px; }
        
        /* Styles for Auth Section */
        #auth-container { 
            padding: 20px; /* Increased padding */
            text-align: center; 
            border-bottom: 1px solid #eee; 
            margin-bottom: 15px; 
            background-color: #f8f9fa; 
            border-radius: 5px;
            display: flex; /* Use flexbox for vertical alignment */
            flex-direction: column; /* Stack items vertically */
            align-items: center; /* Center horizontally */
            justify-content: center; /* Center vertically if container has height */
            min-height: 80px; /* Give it a minimum height for better centering */
        }
        #auth-container h2 { 
            font-size: 1.3em; /* Slightly larger heading */
            margin-bottom: 15px; /* More space below heading */
            color: #333; 
        }
        #user-info-display { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 15px; 
            flex-wrap: wrap;
            margin-top: 10px; /* Add some space above user info */
        }
        #user-info-display img { 
            border-radius: 50%; 
            width: 50px; /* Slightly larger photo */
            height: 50px; 
            border: 2px solid #ddd;
            object-fit: cover; /* Ensure image covers the area */
        }
        #user-info-display .user-details p { 
            margin: 0; 
            font-size: 1em; /* Slightly larger font size */
        }
        #user-info-display .user-details p:first-child { 
            font-weight: bold; 
        }
        #signInBtn, #signOutBtn { 
            padding: 12px 25px; /* Larger buttons */
            font-size: 1.1em; /* Larger font */
            cursor: pointer; 
            border: none; 
            border-radius: 4px; 
            transition: background-color 0.3s ease; 
            margin-top: 10px; /* Space above button */
        }
        #signInBtn { background-color: #4285F4; color: white; } #signInBtn:hover { background-color: #357ae8; }
        #signOutBtn { background-color: #e74c3c; color: white; } #signOutBtn:hover { background-color: #c0392b; }

        /* Initially hide app content and show loading/auth message */
        #app-content { display: none; }
        #loading-auth-message { text-align: center; padding: 20px; font-size: 1.1em; color: #555;}

        h1, h2, h3 { color: #2c3e50; text-align: center; margin-bottom: 12px; font-size: 1.5em; }
        h2 { font-size: 1.3em; }
        h3 { font-size: 1.1em; text-align: left; margin-top: 15px; border-bottom: 1px solid #ccc; padding-bottom: 5px;}
        .action-bar { margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; } /* Added flex-wrap */
        .btn { 
            padding: 2px 5px; /* Reduced padding for smaller buttons */
            border: none; 
            border-radius: 3px; 
            cursor: pointer; 
            font-size: 0.7em; /* Smaller font size */
            transition: background-color 0.3s ease; 
            margin: 1px; /* Reduced margin */
            min-width: 40px; /* Smaller min-width */
            text-align: center; 
            vertical-align: middle;
        }
        .btn-lg { padding: 7px 12px; font-size: 0.9em; }
        .btn-group-toggle { 
            min-width: 25px; 
            padding: 2px 6px; 
            font-size: 0.8em; /* Slightly smaller for group toggle */
            margin-left: 10px; 
            background-color: #7f8c8d; 
            color:white; 
        }
        .btn-group-toggle:hover { background-color: #95a5a6;}
        .btn-danger { background-color: #e74c3c; color: white; } .btn-danger:hover { background-color: #c0392b; }
        .btn-primary { background-color: #3498db; color: white; } .btn-primary:hover { background-color: #2980b9; }
        .btn-success { background-color: #2ecc71; color: white; } .btn-success:hover { background-color: #27ae60; }
        .btn-mark-done { background-color: #1abc9c; color: white; } .btn-mark-done:hover { background-color: #16a085; }
        .btn-release { background-color: #9b59b6; color: white; font-size:0.8em; padding: 3px 8px; } /* Slightly smaller for release */
        .btn-release:hover { background-color: #8e44ad; }
        .btn-day-start { background-color: #007bff; color: white; }
        .btn-day-start:hover { background-color: #0056b3; }
        .btn-day-end { background-color: #fd7e14; color: white; }
        .btn-day-end:hover { background-color: #c85e08; }
        .btn-warning { background-color: #f39c12; color: white; }
        .btn-warning:hover { background-color: #e67e22; }
        .btn-info { background-color: #17a2b8; color: white; } 
        .btn-info:hover { background-color: #138496; }
        .btn:disabled { background-color: #bdc3c7 !important; color: #7f8c8d !important; cursor: not-allowed; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 15px; border: 1px solid #888; width: 90%; border-radius: 5px; position: relative; }
        #projectFormModal .modal-content { max-width: 480px; }
        #tlDashboardModal .modal-content { max-width: 750px; max-height: 85vh; overflow-y: auto;}
        #settingsModal .modal-content { max-width: 550px; max-height: 85vh; overflow-y: auto;} 
        .close-button { color: #aaa; float: right; font-size: 24px; font-weight: bold; } .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #newProjectForm label { display: block; margin-top: 8px; font-weight: bold; font-size: 0.85em;}
        #newProjectForm input[type="text"], #newProjectForm input[type="number"], #newProjectForm select { width: calc(100% - 18px); padding: 7px; margin-top: 3px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box; font-size: 0.85em; }
        #newProjectForm button[type="submit"] { margin-top: 12px; }

        /* Container for horizontal scrolling */
        .table-responsive-container {
            overflow-x: auto; /* Enables horizontal scrolling */
            -webkit-overflow-scrolling: touch; /* Improves scrolling on iOS */
            margin-top: 15px; /* Apply margin here instead of table */
        }

        #projectTable { 
            width: 100%; /* Important: Make table width 100% to fill container */
            border-collapse: collapse; 
            font-size: 0.75em; /* Slightly smaller overall table font size */
            /* Removed table-layout: fixed; here to allow browser to calculate widths more flexibly */
            /* Min-width to ensure table doesn't get too small before scrolling */
            min-width: 1200px; /* Adjust this value based on your content and desired minimum size */
        }
        /* Default for all table cells: allow wrapping unless specified */
        #projectTable th, #projectTable td { 
            border: 1px solid #ddd; 
            padding: 2px 3px; /* Significantly reduced padding for tight rows */
            text-align: left; 
            vertical-align: middle; 
            white-space: normal; /* Changed to normal to allow wrapping by default */
            word-wrap: break-word; /* Ensures long words break if needed */
        }
        #projectTable thead th { 
            background-color: #34495e; 
            color: white; 
            font-weight: bold; 
            position: sticky; 
            top: 0; 
            z-index: 10;
            white-space: nowrap; /* Keep header text on single line */
            line-height: 1.2; /* Reduce line height for headers */
        }
        /* Specific overrides for columns that need to stay on one line */
        #projectTable td.duration-column,
        #projectTable td.total-duration-column {
            white-space: nowrap; /* Keep duration numbers on single line */
            text-align: center; /* Center the numbers for readability */
            min-width: 45px; /* Give a min-width to prevent severe squishing, adjusted */
            line-height: 1.2; /* Adjust line height for numbers */
        }

        /* Input/textarea within table cells */
        #projectTable input[type="text"].assigned-to-input { 
            width: calc(100% - 6px); /* Full width minus padding/border */
            padding: 1px; /* Reduced input padding */
            border: 1px solid #ccc; 
            border-radius: 2px; 
            box-sizing: border-box; 
            font-size: 0.9em; /* Slightly smaller input font */
            background-color: #fff; 
            height: 18px; /* Fixed height for inputs */
            line-height: 1.2; /* Adjust line height */
        }
        #projectTable textarea.tech-notes-input { 
            width: calc(100% - 6px); 
            padding: 1px; /* Reduced textarea padding */
            border: 1px solid #ccc; 
            border-radius: 2px; 
            box-sizing: border-box; 
            font-size: 0.9em; /* Slightly smaller textarea font */
            background-color: #fff; 
            resize: vertical; 
            min-height: 18px; /* Minimum height for textarea */
            max-height: 40px; /* Optional: Max height to prevent overly tall rows */
            line-height: 1.2; /* Adjust line height */
        }

        .batch-header-row td { background-color: #6c757d !important; color: white; font-size: 1.0em; /* Slightly smaller for batch header */ font-weight: bold; text-align: left; padding: 4px 6px; } /* Reduced padding */
        .fix-group-header td { background-color: #adb5bd !important; color: #212529; font-size: 0.95em; /* Slightly smaller for group header */ font-weight: bold; text-align: left; padding: 3px 5px; /* Reduced padding */ cursor:pointer; padding-left: 30px; }
        .hidden-group-row { display: none; }
        .overall-project-separator td { height: 5px !important; background-color: #e9ecef !important; border: none !important; padding: 0 !important; } /* Reduced separator height */
        #projectTable td.duration-column { color: #0056b3; font-weight: bold; }
        #projectTable td.total-duration-column { 
            color: white; 
            font-weight: bold; 
            background-color: #e74c3c; 
        } 
        .fix1-row { background-color: #e6ffe6; }
        .fix2-row { background-color: #ffe6f2; }
        .fix3-row { background-color: #e6e6ff; }
        .fix4-row { background-color: #fff5e6; }
        .reassigned-task-highlight { background-color: #FFF9C4 !important; }
        #projectTable tbody tr:not(.fix-group-header):not(.batch-header-row):not(.overall-project-separator):hover { background-color: #d0e0f0 !important; }
        .status { padding: 1px 3px; border-radius: 3px; color: white; font-weight: bold; text-align: center; display: inline-block; font-size:0.85em; /* Smaller status text */ line-height: 1.2;}
        .status-available { background-color: #3498db; }
        .status-inprogressday1 { background-color: #f39c12; }
        .status-day1ended_awaitingnext { background-color: #f39c12; } 
        .status-inprogressday2 { background-color: #f39c12; }
        .status-inprogressday3 { background-color: #8e44ad; } 
        .status-completed { background-color: #2ecc71; }
        .status-reassigned_techabsent { background-color: #B0BEC5; color: #263238; }
        #tlDashboardContent { margin-top:15px; }
        .dashboard-batch-item { border: 1px solid #bdc3c7; padding: 10px; margin-bottom: 10px; background-color: #fff; border-radius: 4px; }
        .dashboard-batch-item h4 { margin-top: 0; margin-bottom: 8px; font-size: 1.05em; color: #34495e;}
        .dashboard-batch-item p { margin: 3px 0; font-size: 0.9em;}
        .dashboard-batch-actions-release { margin-top: 8px; margin-bottom: 8px; }
        .dashboard-batch-actions-delete { margin-top: 8px; border-top: 1px dashed #ccc; padding-top: 8px; display: flex; flex-wrap: wrap; gap: 5px;}
        .break-select {
            padding: 1px 3px; /* Reduced padding for select */
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8em; /* Smaller font for select */
            min-width: 80px; /* Adjusted min-width for select */
            margin-left: 2px; /* Reduced margin */
            height: 20px; /* Fixed height to match inputs */
        }
        /* Styles for Settings Modal */
        #allowedEmailsList { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; margin-bottom: 10px;}
        #allowedEmailsList li { padding: 8px; border-bottom: 1px dashed #eee; display: flex; justify-content: space-between; align-items: center;}
        #allowedEmailsList li:last-child { border-bottom: none; }
        #allowedEmailsList li button { background-color: #dc3545; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-size: 0.8em;}
        #allowedEmailsList li button:hover { background-color: #c82333; }
        #addEmailInput { flex-grow: 1; padding: 7px; margin-right: 5px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box; font-size: 0.9em;}
        .settings-input-group { display: flex; margin-bottom: 10px; align-items: center;} 

        /* NEW: Styles for Day 3 columns - Hide them by controlling display of headers/cells */
        .day3-column-header, 
        .day3-column-cell {
            display: table-cell; /* Default display */
        }

        /* Class added by JS to hide Day 3 columns */
        .hide-day3-column {
            display: none !important;
        }

        /* Additional min-width for important columns to prevent squishing even in auto-layout */
        /* These min-widths are crucial for horizontal scrolling to work effectively */
        #projectTable th:nth-child(2), /* Project Name */
        #projectTable td:nth-child(2) {
            min-width: 130px; /* Minimum width for project name, adjusted */
        }
        #projectTable th:nth-child(5), /* Assigned Tech */
        #projectTable td:nth-child(5) {
            min-width: 70px; /* Minimum width for assigned tech, adjusted */
        }
        #projectTable th:nth-child(6), /* Status */
        #projectTable td:nth-child(6) {
            min-width: 90px; /* Minimum width for status, adjusted */
        }
        #projectTable th:nth-child(7), /* D1 Start */
        #projectTable td:nth-child(7),
        #projectTable th:nth-child(8), /* D1 End */
        #projectTable td:nth-child(8),
        #projectTable th:nth-child(10), /* D2 Start */
        #projectTable td:nth-child(10),
        #projectTable th:nth-child(11), /* D2 End */
        #projectTable td:nth-child(11),
        /* Day 3 times */
        #projectTable th:nth-child(13), /* D3 Start */
        #projectTable td:nth-child(13),
        #projectTable th:nth-child(14), /* D3 End */
        #projectTable td:nth-child(14) {
            min-width: 55px; /* Minimum width for time columns */
        }

        #projectTable th:nth-child(9), /* D1 Dur(m) */
        #projectTable td:nth-child(9),
        #projectTable th:nth-child(12), /* D2 Dur(m) */
        #projectTable td:nth-child(12),
        #projectTable th:nth-child(15), /* D3 Dur(m) */
        #projectTable td:nth-child(15) {
            min-width: 45px; /* Minimum width for duration columns */
            text-align: center;
        }

        #projectTable th:nth-child(16), /* Total(m) */
        #projectTable td:nth-child(16) {
            min-width: 50px; /* Ensure Total(m) maintains reasonable width */
            text-align: center;
        }
        #projectTable th:nth-child(17), /* Break(m) */
        #projectTable td:nth-child(17) {
            min-width: 50px; /* Ensure Break(m) maintains reasonable width */
            text-align: center;
        }
        #projectTable th:nth-child(18), /* Tech Notes */
        #projectTable td:nth-child(18) {
            min-width: 110px; /* Ensure Tech Notes maintains reasonable width */
        }
        #projectTable th:nth-child(19), /* Actions */
        #projectTable td:nth-child(19) {
            min-width: 140px; /* Ensure Actions maintains reasonable width */
        }

    </style>
</head>
<body>
    <div class="container">
        <div id="auth-container">
            <h2></h2> <button id="signInBtn" class="btn btn-primary btn-lg">Sign in with Google</button>
            <div id="user-info-display" style="display: none;">
                <img id="userPhoto" src="" alt="User Photo">
                <div class="user-details">
                    <p id="userName"></p>
                    <p id="userEmail"></p>
                </div>
                <button id="signOutBtn" class="btn btn-danger">Sign Out</button>
            </div>
        </div>
        <div id="loading-auth-message">
            <p>Please sign in to access the Project Tracker.</p>
        </div>
        
        <div id="app-content">
            <h1></h1>
            <div class="action-bar">
                <button id="openAddNewProjectBtn" class="btn btn-success btn-lg">➕ Add New Tracker</button>
                <button id="openTlDashboardBtn" class="btn btn-primary btn-lg">👑 Project Settings</button>
                <button id="openSettingsBtn" class="btn btn-info btn-lg" style="display:none;">⚙️ User Settings</button> </div>

            <div id="projectFormModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeProjectFormBtn">&times;</span>
                    <h2>Add New Tracker</h2>
                    <form id="newProjectForm">
                        <label for="fixCategorySelect">Fix Category:</label>
                        <select id="fixCategorySelect" required><option value="Fix1">Fix1</option><option value="Fix2">Fix2</option><option value="Fix3">Fix3</option><option value="Fix4">Fix4</option></select>
                        <label for="numRows">Number of Area:</label>
                        <input type="number" id="numRows" value="1" min="1" required>
                        <label for="baseProjectName">Project Name:</label>
                        <input type="text" id="baseProjectName" value="PROJ_ID_XYZ" required>
                        <label for="gsd">GSD:</label>
                        <select id="gsd" required><option value="3in">3in</option><option value="9in">9in</option></select>
                        <button type="submit" class="btn btn-success">Add Project(s)</button>
                    </form>
                </div>
            </div>

            <div id="tlDashboardModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeTlDashboardBtn">&times;</span>
                    <h2>👑 Project Settings</h2>
                    <div id="tlDashboardContent"></div>
                </div>
            </div>

            <div id="settingsModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeSettingsBtn">&times;</span>
                    <h2>⚙️ User Settings</h2>
                    <h3>Manage Allowed User Emails</h3>
                    <ul id="allowedEmailsList">
                        </ul>
                    <div class="settings-input-group">
                        <input type="email" id="addEmailInput" placeholder="Enter new allowed email">
                        <button id="addEmailBtn" class="btn btn-success">Add Email</button>
                    </div>
                </div>
            </div>

            <h3>📌 Team123 Project Tracker</h3>
            <div class="table-responsive-container"> <table id="projectTable">
                    <thead>
                        <tr>
                            <th>Fix</th><th>Project Name</th><th>Area</th><th>GSD</th>
                            <th>Assigned Tech</th><th>Status</th>
                            <th>D1 Start</th><th>D1 End</th><th>D1 Dur(m)</th>
                            <th>D2 Start</th><th>D2 End</th><th>D2 Dur(m)</th>
                            <th class="day3-column-header">D3 Start</th>
                            <th class="day3-column-header">D3 End</th>
                            <th class="day3-column-header">D3 Dur(m)</th>
                            <th>Total(m)</th>
                            <th>Break(m)</th> 
                            <th>Tech Notes</th><th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="projectTableBody"></tbody>
                </table>
            </div> </div>
    </div>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    
    <script>
        // CRITICAL SECURITY WARNING: Your Firebase API keys are exposed here.
        // For production, secure your data with Firebase Security Rules and restrict API key usage in Google Cloud Console.
        const firebaseConfig = {
          apiKey: "AIzaSyADB1W9YKaU6DFqGyjivsADJOhuIRY0eZ0", // Replace with your actual key if different
          authDomain: "project-tracker-fddb1.firebaseapp.com",
          projectId: "project-tracker-fddb1",
          storageBucket: "project-tracker-fddb1.firebasestorage.app",
          messagingSenderId: "698282455986",
          appId: "1:698282455986:web:f31fa7830148dc47076aab",
          measurementId: "G-6D2Z9ZWEN1"
        };

        let app;
        let db;
        let auth; // Firebase Auth instance

        // DOM elements for Auth
        let signInBtn, signOutBtn, userInfoDisplayDiv, userNameP, userEmailP, userPhotoImg;
        // DOM elements for app state
        let appContentDiv, loadingAuthMessageDiv;

        // NEW: Hardcoded PIN for TL Dashboard
        const TL_DASHBOARD_PIN = "1234";

        // NEW: Reference for the allowed emails document in Firestore
        const ALLOWED_EMAILS_DOC_REF_PATH = "settings/allowedEmails"; 
        let allowedEmailsFromFirestore = []; // This will hold the dynamic list of allowed emails

        try {
            if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                throw new Error("Firebase SDK not loaded. Ensure Firebase scripts are correctly included.");
            }
            app = firebase.initializeApp(firebaseConfig);
            
            if (typeof app.firestore === 'undefined') {
                 throw new Error("Firestore SDK not loaded or initialized correctly with the app.");
            }
            db = firebase.firestore();

            if (typeof app.auth === 'undefined') {
                throw new Error("Firebase Auth SDK not loaded or initialized correctly with the app.");
            }
            auth = firebase.auth(); 

            console.log("Firebase initialized successfully (App, Firestore, Auth)!");
            // Initialize allowedEmailsFromFirestore by fetching it
            fetchAllowedEmails(); 

        } catch (e) {
            console.error("CRITICAL: Error initializing Firebase: ", e.message);
            const loadingMsgDiv = document.getElementById('loading-auth-message');
            if (loadingMsgDiv) loadingMsgDiv.innerHTML = `<p style="color:red;">CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: ${e.message}</p>`;
            else alert("CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: " + e.message);
        }

        const FIX_CATEGORIES_ORDER = ["Fix1", "Fix2", "Fix3", "Fix4"];
        const STATUS_ORDER = {
            'Available': 1, 'InProgressDay1': 2, 'Day1Ended_AwaitingNext': 3,
            'InProgressDay2': 4, 'Completed': 5, 'Reassigned_TechAbsent': 6,
            'InProgressDay3': 7 // NEW: Day 3 Status
        };
        const NUM_TABLE_COLUMNS = 19; // Updated from 16 to 19 for Day 3 columns
        // END NEW

        let openAddNewProjectBtn, openTlDashboardBtn, openSettingsBtn, projectFormModal, tlDashboardModal, settingsModal,
            closeProjectFormBtn, closeTlDashboardBtn, closeSettingsBtn, newProjectForm, projectTableBody,
            tlDashboardContentElement, allowedEmailsList, addEmailInput, addEmailBtn; 

        let projects = [];
        let groupVisibilityState = {};
        let isAppInitialized = false; 
        let firestoreListenerUnsubscribe = null; 

        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }
        function formatMillisToMinutes(millis) { return (millis === null || typeof millis !== 'number' || millis < 0) ? 'N/A' : Math.floor(millis / 60000); }

        function calculateDurationMs(startTime, endTime) {
            let startMillis = startTime; let endMillis = endTime;
            if (startTime && typeof startTime.toMillis === 'function') startMillis = startTime.toMillis();
            if (endTime && typeof endTime.toMillis === 'function') endMillis = endTime.toMillis();
            else if (typeof startTime === 'number' && typeof endTime === 'number') { /* proceed */ }
            else if (startTime && typeof startTime.toMillis === 'function' && typeof endTime === 'number') { /* endMillis is already a number */ }
            else if (typeof startTime === 'number' && endTime && typeof endTime.toMillis === 'function') { /* startMillis is already a number */ }
            else {
                 if (!startTime || !endTime) return null;
                 if (typeof startTime !== 'number' && !isNaN(new Date(startTime).getTime())) startMillis = new Date(startTime).getTime();
                 if (typeof endTime !== 'number' && !isNaN(new Date(endTime).getTime())) endMillis = new Date(endTime).getTime();
            }
            return (!startMillis || !endMillis || endMillis < startMillis || isNaN(startMillis) || isNaN(endMillis)) ? null : endMillis - startMillis;
        }
        
        function loadGroupVisibilityState() { 
            try { 
                const savedState = localStorage.getItem('projectTrackerGroupVisibility'); 
                if (savedState) groupVisibilityState = JSON.parse(savedState); 
                else groupVisibilityState = {}; 
                // Ensure isDay3Expanded is set for existing groups, defaults to false
                for (const key in groupVisibilityState) {
                    if (groupVisibilityState.hasOwnProperty(key) && groupVisibilityState[key].isDay3Expanded === undefined) {
                        groupVisibilityState[key].isDay3Expanded = false;
                    }
                }
            } catch (e) { 
                console.error("Error parsing group visibility state from localStorage:", e); 
                groupVisibilityState = {}; 
            }
        }
        function saveGroupVisibilityState() { 
            try { localStorage.setItem('projectTrackerGroupVisibility', JSON.stringify(groupVisibilityState)); } catch (lsError) { console.error("Error saving group visibility state to localStorage:", lsError); alert("Warning: Could not save your group visibility preferences.");}
        }

        async function fetchAllowedEmails() {
            if (!db) { console.error("Firestore (db) not initialized. Cannot fetch allowed emails."); return; }
            try {
                const docRef = db.doc(ALLOWED_EMAILS_DOC_REF_PATH);
                const docSnap = await docRef.get();
                if (docSnap.exists) {
                    allowedEmailsFromFirestore = docSnap.data().emails || [];
                    console.log("Allowed emails fetched from Firestore:", allowedEmailsFromFirestore);
                } else {
                    console.log("No allowed emails document found. Initializing with an empty array. Adding default email.");
                    allowedEmailsFromFirestore = [];
                    // Add your default email here if the document doesn't exist yet
                    allowedEmailsFromFirestore.push("ev.lorens.ebrado@gmail.com");
                    // Optionally, you might want to save this initial state to Firestore
                    // await updateAllowedEmailsInFirestore(allowedEmailsFromFirestore); // Uncomment this if you want it saved automatically on first run
                }
            } catch (error) {
                console.error("Error fetching allowed emails:", error);
                alert("Error fetching allowed emails from settings. Check console. Error: " + error.message);
                allowedEmailsFromFirestore = [];
            }
        }

        async function updateAllowedEmailsInFirestore(newEmailsArray) {
            if (!db) { alert("Database not initialized! Cannot update allowed emails."); return false; }
            const docRef = db.doc(ALLOWED_EMAILS_DOC_REF_PATH);
            try {
                await docRef.set({ emails: newEmailsArray });
                allowedEmailsFromFirestore = newEmailsArray; 
                console.log("Allowed emails updated in Firestore.");
                return true;
            } catch (error) {
                console.error("Error updating allowed emails in Firestore:", error);
                alert("Error saving allowed emails. Error: " + error.message + "\n\nEnsure your Firebase Security Rules permit writes to 'settings/allowedEmails' for authenticated users.");
                return false;
            }
        }

        function initializeFirebaseAndLoadData() {
            if (!db) { console.error("Firestore (db) not initialized. Cannot load data."); alert("ERROR: Database connection failed. App cannot load data."); projects = []; refreshAllViews(); return; }
            
            if (firestoreListenerUnsubscribe) {
                firestoreListenerUnsubscribe();
                console.log("Previous Firestore listener detached.");
            }

            loadGroupVisibilityState();
            try {
                db.collection("projects").orderBy("batchId").orderBy("fixCategory").orderBy("areaTask")
                  .onSnapshot((querySnapshot) => {
                    const firebaseProjects = [];
                    querySnapshot.forEach((doc) => { if (doc.exists && typeof doc.data === 'function') firebaseProjects.push({ id: doc.id, ...doc.data() }); });
                    projects = firebaseProjects;
                    projects.forEach(p => { 
                        if (p && p.batchId && p.fixCategory) { 
                            const groupStateKey = `${p.batchId}_${p.fixCategory}`; 
                            if (groupVisibilityState[groupStateKey] === undefined) {
                                groupVisibilityState[groupStateKey] = { isExpanded: true, isDay3Expanded: false }; // Initialize Day 3 state here too
                            }
                            if (p.breakDurationMinutes === undefined) {
                                p.breakDurationMinutes = 0; 
                            }
                            // Ensure Day 3 fields exist for older projects
                            if (p.startTimeDay3 === undefined) p.startTimeDay3 = null;
                            if (p.finishTimeDay3 === undefined) p.finishTimeDay3 = null;
                            if (p.durationDay3Ms === undefined) p.durationDay3Ms = null;
                        } 
                    });
                    refreshAllViews();
                }, (error) => { 
                    console.error("Error fetching projects from Firebase (onSnapshot): ", error); 
                    alert("Error fetching projects. Check console. Error: " + error.message + "\n\nThis could be due to Firebase Security Rules denying access."); 
                    projects = []; refreshAllViews(); 
                });
                console.log("New Firestore listener attached.");
            } catch (fbError) { console.error("CRITICAL Error setting up Firebase listener: ", fbError); alert("A critical error occurred while listening for project updates. Error: " + fbError.message); }
        }

        function setupDOMReferences() {
            openAddNewProjectBtn = document.getElementById('openAddNewProjectBtn');
            openTlDashboardBtn = document.getElementById('openTlDashboardBtn');
            openSettingsBtn = document.getElementById('openSettingsBtn'); 
            projectFormModal = document.getElementById('projectFormModal');
            tlDashboardModal = document.getElementById('tlDashboardModal');
            settingsModal = document.getElementById('settingsModal'); 
            closeProjectFormBtn = document.getElementById('closeProjectFormBtn');
            closeTlDashboardBtn = document.getElementById('closeTlDashboardBtn');
            closeSettingsBtn = document.getElementById('closeSettingsBtn'); 
            newProjectForm = document.getElementById('newProjectForm');
            projectTableBody = document.getElementById('projectTableBody');
            tlDashboardContentElement = document.getElementById('tlDashboardContent');
            allowedEmailsList = document.getElementById('allowedEmailsList'); 
            addEmailInput = document.getElementById('addEmailInput'); 
            addEmailBtn = document.getElementById('addEmailBtn'); 

            if (!openAddNewProjectBtn || !newProjectForm || !projectTableBody || !tlDashboardContentElement || !projectFormModal || !tlDashboardModal || !openSettingsBtn || !settingsModal || !allowedEmailsList || !addEmailInput || !addEmailBtn) {
                console.error("CRITICAL DOM ERROR: One or more essential tracker elements not found!");
            }
        }

        function attachEventListeners() {
            if (openAddNewProjectBtn) openAddNewProjectBtn.onclick = () => { if (projectFormModal) projectFormModal.style.display = 'block'; else console.error("Cannot open Add Project modal: projectFormModal is null."); };
            if (closeProjectFormBtn) closeProjectFormBtn.onclick = () => { if (projectFormModal) projectFormModal.style.display = 'none'; };
            
            if (openTlDashboardBtn) { 
                openTlDashboardBtn.onclick = () => {
                    const pin = prompt("Enter PIN to access Project Settings:");
                    if (pin === TL_DASHBOARD_PIN) {
                        if (tlDashboardModal) { tlDashboardModal.style.display = 'block'; renderTLDashboard(); }
                        else console.error("Cannot open Project Settings: tlDashboardModal is null.");
                    } else {
                        alert("Incorrect PIN. Access Denied. ");
                    }
                };
            }
            if (closeTlDashboardBtn) closeTlDashboardBtn.onclick = () => { if (tlDashboardModal) tlDashboardModal.style.display = 'none'; };

            if (openSettingsBtn) openSettingsBtn.onclick = () => { if (settingsModal) { settingsModal.style.display = 'block'; renderAllowedEmailsList(); } else console.error("Cannot open Settings modal: settingsModal is null."); };
            if (closeSettingsBtn) closeSettingsBtn.onclick = () => { if (settingsModal) settingsModal.style.display = 'none'; };
            if (addEmailBtn) addEmailBtn.onclick = handleAddEmail;

            if (typeof window !== 'undefined') {
                window.onclick = (event) => {
                    if (projectFormModal && event.target == projectFormModal) projectFormModal.style.display = 'none';
                    if (tlDashboardModal && event.target == tlDashboardModal) tlDashboardModal.style.display = 'none';
                    if (settingsModal && event.target == settingsModal) settingsModal.style.display = 'none'; 
                };
            }
            if (newProjectForm) newProjectForm.addEventListener('submit', handleAddProjectSubmit);
            else console.error("Cannot attach submit listener: newProjectForm not found.");
        }

        async function handleAddProjectSubmit(e) { 
            e.preventDefault(); 
            if (!db) { alert("CRITICAL: Database not initialized! Cannot add projects."); return; } 
            
            const fixCategoryElement = document.getElementById('fixCategorySelect'); 
            const numRowsElement = document.getElementById('numRows'); 
            const baseProjectNameElement = document.getElementById('baseProjectName'); 
            const gsdElement = document.getElementById('gsd'); 
            
            if (!fixCategoryElement || !numRowsElement || !baseProjectNameElement || !gsdElement) { 
                alert("Error: Form elements missing. Could not submit."); return; 
            } 
            
            const fixCategory = fixCategoryElement.value; 
            const numRows = parseInt(numRowsElement.value, 10); 
            const baseProjectNameVal = baseProjectNameElement.value.trim(); 
            const gsd = gsdElement.value; 
            
            if (!baseProjectNameVal) { alert("Base Project Name cannot be empty."); return; } 
            if (isNaN(numRows) || numRows < 1) { alert("Number of Tasks must be a positive number."); return; } 
            
            const currentBatchId = "batch_" + generateId(); 
            const batchCreationTimestamp = firebase.firestore.FieldValue.serverTimestamp(); 
            const fbBatch = db.batch(); 
            
            try { 
                for (let i = 1; i <= numRows; i++) { 
                    const currentAreaTask = `Area${String(i).padStart(2, '0')}`; 
                    const newProjectData = { 
                        batchId: currentBatchId, 
                        creationTimestamp: batchCreationTimestamp, 
                        fixCategory: fixCategory, 
                        baseProjectName: baseProjectNameVal, 
                        areaTask: currentAreaTask, 
                        gsd: gsd, 
                        assignedTo: "", 
                        techNotes: "", 
                        status: 'Available', 
                        startTimeDay1: null, 
                        finishTimeDay1: null, 
                        durationDay1Ms: null, 
                        startTimeDay2: null, 
                        finishTimeDay2: null, 
                        durationDay2Ms: null, 
                        // NEW: Day 3 fields
                        startTimeDay3: null, 
                        finishTimeDay3: null, 
                        durationDay3Ms: null, 
                        // END NEW
                        releasedToNextStage: false, 
                        lastModifiedTimestamp: batchCreationTimestamp, 
                        isReassigned: false, 
                        originalProjectId: null,
                        breakDurationMinutes: 0 
                    }; 
                    const docRef = db.collection("projects").doc(); 
                    fbBatch.set(docRef, newProjectData); 
                } 
                await fbBatch.commit(); 
                if (newProjectForm) newProjectForm.reset(); 
            } catch (error) { 
                console.error("Error adding projects to Firebase: ", error); 
                alert("Error adding projects. Error: " + error.message); 
            } finally { 
                if (projectFormModal) projectFormModal.style.display = 'none'; 
            }
        }

        function getManageableBatches() { 
            const allBatchesInfo = {}; 
            projects.forEach(p => { 
                if (p && p.batchId) { 
                    if (!allBatchesInfo[p.batchId]) allBatchesInfo[p.batchId] = { batchId: p.batchId, baseProjectName: p.baseProjectName || "N/A", tasksByFix: {} }; 
                    if (p.fixCategory && !allBatchesInfo[p.batchId].tasksByFix[p.fixCategory]) allBatchesInfo[p.batchId].tasksByFix[p.fixCategory] = []; 
                    if (p.fixCategory) allBatchesInfo[p.batchId].tasksByFix[p.fixCategory].push(p); 
                } 
            }); 
            return Object.values(allBatchesInfo);
        }

        function renderTLDashboard() { 
            if (!tlDashboardContentElement) { console.error("tlDashboardContentElement not found."); return; } 
            tlDashboardContentElement.innerHTML = ''; 
            const manageableBatches = getManageableBatches(); 
            if (manageableBatches.length === 0) { tlDashboardContentElement.innerHTML = '<p>No project batches found.</p>'; return; } 
            
            manageableBatches.forEach(batch => { 
                if (!batch || !batch.batchId) return; 
                const batchDiv = document.createElement('div'); 
                batchDiv.classList.add('dashboard-batch-item'); 
                
                const title = document.createElement('h4'); 
                title.textContent = `Batch: ${batch.baseProjectName || 'Unknown'} (ID: ${batch.batchId.split('_')[1] || 'N/A'})`; 
                batchDiv.appendChild(title); 
                
                const stagesPresentP = document.createElement('p'); 
                const presentFixCategories = batch.tasksByFix ? Object.keys(batch.tasksByFix).sort((a,b) => FIX_CATEGORIES_ORDER.indexOf(a) - FIX_CATEGORIES_ORDER.indexOf(b)) : []; 
                stagesPresentP.innerHTML = `<strong>Stages Present:</strong> ${presentFixCategories.join(', ') || 'None'}`; 
                batchDiv.appendChild(stagesPresentP); 
                
                const releaseActionsDiv = document.createElement('div'); 
                releaseActionsDiv.classList.add('dashboard-batch-actions-release'); 
                
                let latestFixCategoryForBatch = ""; 
                let allTasksInLatestStageReadyForRelease = false; 
                let alreadyReleasedFromLatestStage = true; 
                
                if (batch.tasksByFix) { 
                    FIX_CATEGORIES_ORDER.slice().reverse().forEach(fixCat => { 
                        if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0 && !latestFixCategoryForBatch) { 
                            latestFixCategoryForBatch = fixCat; 
                            alreadyReleasedFromLatestStage = batch.tasksByFix[fixCat].every(t => t && t.releasedToNextStage && t.status !== 'Reassigned_TechAbsent'); 
                            if (!alreadyReleasedFromLatestStage) {
                                allTasksInLatestStageReadyForRelease = batch.tasksByFix[fixCat]
                                    .filter(t => t.status !== 'Reassigned_TechAbsent')
                                    .every(t => t && (t.status === 'Completed' || t.status === 'Day1Ended_AwaitingNext')); 
                            }
                        } 
                    }); 
                } 
                
                if (latestFixCategoryForBatch && !alreadyReleasedFromLatestStage) { 
                    const currentFixIdx = FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch); 
                    if (currentFixIdx < FIX_CATEGORIES_ORDER.length - 1) { 
                        const nextFixCategory = FIX_CATEGORIES_ORDER[currentFixIdx + 1]; 
                        const releaseBtn = document.createElement('button'); 
                        releaseBtn.textContent = `Release to ${nextFixCategory}`; 
                        releaseBtn.classList.add('btn', 'btn-release'); 
                        if (!allTasksInLatestStageReadyForRelease) { 
                            releaseBtn.disabled = true; 
                            releaseBtn.title = `Not all active tasks in ${latestFixCategoryForBatch} are 'Completed' or 'Day 1 Ended'.`; 
                        } 
                        releaseBtn.onclick = () => releaseBatchToNextFix(batch.batchId, latestFixCategoryForBatch, nextFixCategory); 
                        releaseActionsDiv.appendChild(releaseBtn); 
                    } 
                } else if (alreadyReleasedFromLatestStage && latestFixCategoryForBatch && FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch) < FIX_CATEGORIES_ORDER.length -1) { 
                    const releasedInfoP = document.createElement('p'); 
                    releasedInfoP.innerHTML = `<small><em>(Active tasks released from ${latestFixCategoryForBatch})</em></small>`; 
                    releaseActionsDiv.appendChild(releasedInfoP); 
                } 
                batchDiv.appendChild(releaseActionsDiv); 
                
                const deleteActionsDiv = document.createElement('div'); 
                deleteActionsDiv.classList.add('dashboard-batch-actions-delete'); 
                
                if (batch.tasksByFix) { 
                    FIX_CATEGORIES_ORDER.forEach(fixCat => { 
                        if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0) { 
                            const deleteFixBtn = document.createElement('button'); 
                            deleteFixBtn.textContent = `Delete ${fixCat} Tasks`; 
                            deleteFixBtn.classList.add('btn', 'btn-danger'); 
                            deleteFixBtn.onclick = () => { if (confirm(`Are you sure you want to delete all ${fixCat} tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteSpecificFixTasksForBatch(batch.batchId, fixCat); }; 
                            deleteActionsDiv.appendChild(deleteFixBtn); 
                        } 
                    }); 
                } 
                
                const deleteAllBtn = document.createElement('button'); 
                deleteAllBtn.textContent = 'Delete ALL Tasks for this Batch'; 
                deleteAllBtn.classList.add('btn', 'btn-danger'); 
                deleteAllBtn.onclick = () => { if (confirm(`Are you sure you want to delete ALL tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteProjectBatch(batch.batchId); }; 
                deleteActionsDiv.appendChild(deleteAllBtn); 
                batchDiv.appendChild(deleteActionsDiv); 
                tlDashboardContentElement.appendChild(batchDiv); 
            });
        }

        async function releaseBatchToNextFix(batchId, currentFixCategory, nextFixCategory) { 
            if (!db) { alert("Database not initialized!"); return; } 
            if (!batchId || !currentFixCategory || !nextFixCategory) { alert("Error: Missing info to release batch."); return; } 
            
            try { 
                const sourceTasksSnapshot = await db.collection("projects").where("batchId", "==", batchId).where("fixCategory", "==", currentFixCategory).where("releasedToNextStage", "==", false).get(); 
                if (sourceTasksSnapshot.empty) { alert("No active tasks found for this batch in the current stage to release, or they may have already been released."); refreshAllViews(); return; } 
                
                const sourceBatchTasks = []; 
                sourceTasksSnapshot.forEach(doc => { const data = doc.data(); if (data.status !== 'Reassigned_TechAbsent') sourceBatchTasks.push({id: doc.id, ...data }); }); 
                
                if (sourceBatchTasks.length === 0) { alert("No active tasks found for this batch in the current stage to release after filtering."); refreshAllViews(); return; } 
                
                const allReadyForRelease = sourceBatchTasks.every(p => p && (p.status === 'Completed' || p.status === 'Day1Ended_AwaitingNext')); 
                if (!allReadyForRelease) { alert(`Not all active tasks in batch ID ${batchId} for ${currentFixCategory} are 'Completed' or 'Day 1 Ended'. Cannot release.`); return; } 
                
                const releaseTimestamp = firebase.firestore.FieldValue.serverTimestamp(); 
                const fbBatch = db.batch(); 
                
                for (const sourceTask of sourceBatchTasks) { 
                    if (!sourceTask || !sourceTask.id) continue; 
                    const q = db.collection("projects").where("batchId", "==", sourceTask.batchId).where("areaTask", "==", sourceTask.areaTask).where("fixCategory", "==", nextFixCategory); 
                    const existingNextStageTaskSnapshot = await q.get(); 
                    
                    let newDocCreated = false; 
                    if (existingNextStageTaskSnapshot.empty) { 
                        const newTaskData = { 
                            batchId: sourceTask.batchId, 
                            creationTimestamp: sourceTask.creationTimestamp, 
                            fixCategory: nextFixCategory, 
                            baseProjectName: sourceTask.baseProjectName, 
                            areaTask: sourceTask.areaTask, 
                            gsd: sourceTask.gsd, 
                            assignedTo: sourceTask.assignedTo, 
                            techNotes: "", 
                            status: 'Available', 
                            startTimeDay1: null, 
                            finishTimeDay1: null, 
                            durationDay1Ms: null, 
                            startTimeDay2: null, 
                            finishTimeDay2: null, 
                            durationDay2Ms: null, 
                            // NEW: Day 3 fields for new task
                            startTimeDay3: null, 
                            finishTimeDay3: null, 
                            durationDay3Ms: null, 
                            // END NEW
                            releasedToNextStage: false, 
                            lastModifiedTimestamp: releaseTimestamp, 
                            isReassigned: false, 
                            originalProjectId: sourceTask.id,
                            breakDurationMinutes: 0 
                        }; 
                        const newDocRef = db.collection("projects").doc(); 
                        fbBatch.set(newDocRef, newTaskData); 
                        newDocCreated = true; 
                    } else console.log(`Task for ${sourceTask.areaTask} in ${nextFixCategory} already exists. Marking current as released.`); 
                    
                    const sourceDocRef = db.collection("projects").doc(sourceTask.id); 
                    fbBatch.update(sourceDocRef, { releasedToNextStage: true, lastModifiedTimestamp: releaseTimestamp }); 
                } 
                await fbBatch.commit(); 
                console.log(`Batch ${batchId} (${currentFixCategory}) active tasks processed for release to ${nextFixCategory}.`); 
            } catch (error) { 
                console.error("Error releasing batch to Firebase:", error); 
                alert("Error releasing batch. Error: " + error.message); 
            }
        }

        async function deleteProjectBatch(batchIdToDelete) { 
            if (!db) { alert("Database not initialized!"); return; } 
            if (!batchIdToDelete) { alert("Error: No Batch ID provided for deletion."); return; } 
            try { 
                const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).get(); 
                if (querySnapshot.empty) { console.log(`No projects for batch ${batchIdToDelete} to delete.`); return; } 
                const fbBatch = db.batch(); 
                querySnapshot.forEach(doc => fbBatch.delete(doc.ref)); 
                await fbBatch.commit(); 
                console.log(`Batch ${batchIdToDelete} deleted.`); 
            } catch (error) { 
                console.error(`Error deleting batch ${batchIdToDelete}:`, error); 
                alert("Error deleting batch. Error: " + error.message); 
            }
        }

        async function deleteSpecificFixTasksForBatch(batchIdToDelete, fixCategoryToDelete) { 
            if (!db) { alert("Database not initialized!"); return; } 
            if (!batchIdToDelete || !fixCategoryToDelete) { alert("Error: Missing Batch ID or Fix Category."); return; } 
            try { 
                const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).where("fixCategory", "==", fixCategoryToDelete).get(); 
                if (querySnapshot.empty) { console.log(`No ${fixCategoryToDelete} tasks for batch ${batchIdToDelete} to delete.`); return; } 
                const fbBatch = db.batch(); 
                querySnapshot.forEach(doc => fbBatch.delete(doc.ref)); 
                await fbBatch.commit(); 
                console.log(`${fixCategoryToDelete} tasks for batch ${batchIdToDelete} deleted.`); 
            } catch (error) { 
                console.error(`Error deleting ${fixCategoryToDelete} for batch ${batchIdToDelete}:`, error); 
                alert("Error deleting specific fix tasks. Error: " + error.message); 
            }
        }

        function renderProjects() { 
            if (!projectTableBody) { console.error("CRITICAL: projectTableBody not found."); return; } 
            projectTableBody.innerHTML = ''; 
            const projectsToRender = [...projects]; 
            
            try { 
                projectsToRender.sort((a, b) => { 
                    if (!a || !b) return 0; 
                    if ((a.batchId || "") < (b.batchId || "")) return -1; 
                    if ((a.batchId || "") > (b.batchId || "")) return 1; 
                    
                    const fixOrderA = FIX_CATEGORIES_ORDER.indexOf(a.fixCategory || ""); 
                    const fixOrderB = FIX_CATEGORIES_ORDER.indexOf(b.fixCategory || ""); 
                    if (fixOrderA < fixOrderB) return -1; 
                    if (fixOrderA > fixOrderB) return 1; 
                    
                    if ((a.areaTask || "") < (b.areaTask || "")) return -1; 
                    if ((a.areaTask || "") > (b.areaTask || "")) return 1; 
                    
                    if ((a.areaTask || "") === (b.areaTask || "")) { 
                        let tsA_create = a.creationTimestamp; 
                        let tsB_create = b.creationTimestamp; 
                        if (tsA_create && typeof tsA_create.toMillis === 'function') tsA_create = tsA_create.toMillis(); 
                        if (tsB_create && typeof tsB_create.toMillis === 'function') tsB_create = tsB_create.toMillis(); 
                        tsA_create = typeof tsA_create === 'number' ? tsA_create : 0; 
                        tsB_create = typeof tsB_create === 'number' ? tsB_create : 0; 
                        if (tsA_create > tsB_create) return -1; 
                        if (tsA_create < tsB_create) return 1; 
                    } 
                    
                    const statusAVal = STATUS_ORDER[a.status || ""] || 99; 
                    const statusBVal = STATUS_ORDER[b.status || ""] || 99; 
                    if (statusAVal < statusBVal) return -1; 
                    if (statusAVal > statusBVal) return 1; 
                    return 0; 
                }); 
            } catch(sortError) { console.error("Error during project sort:", sortError); } 
            
            let currentBatchIdForDisplay = null; 
            let currentFixCategoryForHeader = null; 
            
            // Determine overall Day 3 visibility for the table headers and colgroup
            let overallDay3Visibility = false;
            for (const key in groupVisibilityState) {
                if (groupVisibilityState.hasOwnProperty(key)) {
                    const group = groupVisibilityState[key];
                    if (group.isExpanded && group.isDay3Expanded) {
                        overallDay3Visibility = true;
                        break;
                    }
                }
            }

            // Apply visibility to header cells
            const day3HeaderCells = document.querySelectorAll('#projectTable .day3-column-header');
            day3HeaderCells.forEach(th => {
                if (overallDay3Visibility) {
                    th.classList.remove('hide-day3-column');
                } else {
                    th.classList.add('hide-day3-column');
                }
            });

            projectsToRender.forEach(project => { 
                if (!project || !project.id || !project.batchId || !project.fixCategory) { console.warn("Skipping malformed project:", project); return; } 
                
                if (project.batchId !== currentBatchIdForDisplay) { 
                    currentBatchIdForDisplay = project.batchId; 
                    currentFixCategoryForHeader = null; 
                    const batchHeaderRow = projectTableBody.insertRow(); 
                    batchHeaderRow.classList.add('batch-header-row'); 
                    const batchHeaderCell = batchHeaderRow.insertCell(); 
                    batchHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString()); 
                    batchHeaderCell.textContent = `Project Batch: ${project.baseProjectName || 'Unknown'} (ID: ${project.batchId.split('_')[1] || 'N/A'})`; 
                } 
                
                if (project.fixCategory !== currentFixCategoryForHeader) { 
                    currentFixCategoryForHeader = project.fixCategory; 
                    const groupStateKey = `${project.batchId}_${currentFixCategoryForHeader}`; 
                    if (groupVisibilityState[groupStateKey] === undefined) groupVisibilityState[groupStateKey] = { isExpanded: true, isDay3Expanded: false }; 
                    
                    const groupHeaderRow = projectTableBody.insertRow(); 
                    groupHeaderRow.classList.add('fix-group-header'); 
                    const groupHeaderCell = groupHeaderRow.insertCell(); 
                    groupHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString()); 
                    
                    const toggleBtn = document.createElement('button'); 
                    toggleBtn.classList.add('btn', 'btn-group-toggle'); 
                    const isExpanded = groupVisibilityState[groupStateKey]?.isExpanded !== false; 
                    toggleBtn.textContent = isExpanded ? '−' : '+'; 
                    toggleBtn.title = isExpanded ? `Collapse ${currentFixCategoryForHeader}` : `Expand ${currentFixCategoryForHeader}`; 
                    
                    groupHeaderCell.appendChild(document.createTextNode(`${currentFixCategoryForHeader} `)); 
                    groupHeaderCell.appendChild(toggleBtn); 

                    // NEW: Day 3 Toggle Button
                    const day3ToggleBtn = document.createElement('button');
                    day3ToggleBtn.classList.add('btn', 'btn-group-toggle');
                    day3ToggleBtn.style.marginLeft = '10px';
                    const isDay3Expanded = groupVisibilityState[groupStateKey]?.isDay3Expanded === true;
                    day3ToggleBtn.textContent = isDay3Expanded ? 'Hide Day3' : 'Show Day3';
                    day3ToggleBtn.title = isDay3Expanded ? `Hide Day 3 times for ${currentFixCategoryForHeader}` : `Show Day 3 times for ${currentFixCategoryForHeader}`;
                    day3ToggleBtn.onclick = (e) => {
                        e.stopPropagation(); // Prevent the group header click event from firing
                        if (groupVisibilityState[groupStateKey]) {
                            groupVisibilityState[groupStateKey].isDay3Expanded = !groupVisibilityState[groupStateKey].isDay3Expanded;
                            saveGroupVisibilityState();
                            renderProjects(); // Re-render to apply visibility changes
                        }
                    };
                    groupHeaderCell.appendChild(day3ToggleBtn);
                    // END NEW
                    
                    groupHeaderCell.onclick = (e) => { 
                        if (e.target === toggleBtn || e.target === groupHeaderCell || groupHeaderCell.contains(e.target)) { 
                            if (groupVisibilityState[groupStateKey]) { 
                                groupVisibilityState[groupStateKey].isExpanded = !groupVisibilityState[groupStateKey].isExpanded; 
                                saveGroupVisibilityState(); 
                                renderProjects(); 
                            } 
                        } 
                    }; 
                } 
                
                const row = projectTableBody.insertRow(); 
                const currentGroupStateKeyForRow = `${project.batchId}_${project.fixCategory}`; 
                if (!(groupVisibilityState[currentGroupStateKeyForRow]?.isExpanded !== false)) row.classList.add('hidden-group-row'); 
                
                if (project.fixCategory) row.classList.add(`${project.fixCategory.toLowerCase()}-row`); 
                if (project.isReassigned) row.classList.add('reassigned-task-highlight'); 
                
                row.insertCell().textContent = project.fixCategory || 'N/A'; 
                const baseNameCell = row.insertCell(); 
                baseNameCell.textContent = project.baseProjectName || 'N/A'; 
                baseNameCell.classList.add('wrap-text'); 
                row.insertCell().textContent = project.areaTask || 'N/A'; 
                row.insertCell().textContent = project.gsd || 'N/A'; 
                
                const assignedToCell = row.insertCell(); 
                const assignedToInput = document.createElement('input'); 
                assignedToInput.type = 'text'; 
                assignedToInput.value = project.assignedTo || ''; 
                assignedToInput.placeholder = 'ID'; 
                assignedToInput.classList.add('assigned-to-input'); 
                assignedToInput.disabled = project.status === 'Reassigned_TechAbsent'; 
                assignedToInput.onchange = async (event) => { 
                    const newVal = event.target.value.trim(); 
                    if (!db || !project.id) { alert("Error: Cannot save. DB or ID missing."); event.target.value = project.assignedTo || ''; return; } 
                    try { 
                        await db.collection("projects").doc(project.id).update({ assignedTo: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() }); 
                    } catch (error) { 
                        console.error("Error updating assignedTo:", error); 
                        alert("Error saving 'Assigned To'. Error: " + error.message); 
                        event.target.value = project.assignedTo || ''; 
                    } 
                }; 
                assignedToCell.appendChild(assignedToInput); 
                
                const statusCell = row.insertCell(); 
                const statusSpan = document.createElement('span'); 
                statusSpan.classList.add('status'); 
                let statusText = (project.status || "Unknown").replace(/([A-Z])(?=[a-z0-9_])/g, ' $1').trim(); 
                if (project.status === "Day1Ended_AwaitingNext") statusText = "Started Available"; 
                if (project.status === "Reassigned_TechAbsent") statusText = "Re-Assigned"; 
                statusSpan.textContent = statusText; 
                statusSpan.classList.add(`status-${(project.status || "unknown").toLowerCase()}`); 
                statusCell.appendChild(statusSpan); 
                
                const timeFormatOptions = { hour: 'numeric', minute: '2-digit', hour12: true }; 
                let d1s = project.startTimeDay1, d1f = project.finishTimeDay1, 
                    d2s = project.startTimeDay2, d2f = project.finishTimeDay2,
                    d3s = project.startTimeDay3, d3f = project.finishTimeDay3; // NEW: Day 3
                try { 
                    if (d1s && typeof d1s.toDate === 'function') d1s = d1s.toDate(); 
                    else if (d1s) d1s = new Date(d1s); 
                    else d1s = null; 
                    if (d1f && typeof d1f.toDate === 'function') d1f = d1f.toDate(); 
                    else if (d1f) d1f = new Date(d1f); 
                    else d1f = null; 
                    if (d2s && typeof d2s.toDate === 'function') d2s = d2s.toDate(); 
                    else if (d2s) d2s = new Date(d2s); 
                    else d2s = null; 
                    if (d2f && typeof d2f.toDate === 'function') d2f = d2f.toDate(); 
                    else if (d2f) d2f = new Date(d2f); 
                    else d2f = null; 
                    // NEW: Day 3 Date Parsing
                    if (d3s && typeof d3s.toDate === 'function') d3s = d3s.toDate(); 
                    else if (d3s) d3s = new Date(d3s); 
                    else d3s = null; 
                    if (d3f && typeof d3f.toDate === 'function') d3f = d3f.toDate(); 
                    else if (d3f) d3f = new Date(d3f); 
                    else d3f = null; 
                    // END NEW
                } catch (dateError) { console.error("Error parsing date for " + project.id, dateError); d1s = d1f = d2s = d2f = d3s = d3f = null; } // NEW: Reset d3 dates too
                
                row.insertCell().textContent = d1s && !isNaN(d1s) ? d1s.toLocaleTimeString('en-US', timeFormatOptions) : '-'; 
                row.insertCell().textContent = d1f && !isNaN(d1f) ? d1f.toLocaleTimeString('en-US', timeFormatOptions) : '-'; 
                row.insertCell().textContent = formatMillisToMinutes(project.durationDay1Ms); 
                row.insertCell().textContent = d2s && !isNaN(d2s) ? d2s.toLocaleTimeString('en-US', timeFormatOptions) : '-'; 
                row.insertCell().textContent = d2f && !isNaN(d2f) ? d2f.toLocaleTimeString('en-US', timeFormatOptions) : '-'; 
                row.insertCell().textContent = formatMillisToMinutes(project.durationDay2Ms); 
                
                // NEW: Day 3 Cells and Visibility
                const d3sCell = row.insertCell();
                const d3fCell = row.insertCell();
                const d3DurCell = row.insertCell();

                d3sCell.textContent = d3s && !isNaN(d3s) ? d3s.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                d3fCell.textContent = d3f && !isNaN(d3f) ? d3f.toLocaleTimeString('en-US', timeFormatOptions) : '-';
                d3DurCell.textContent = formatMillisToMinutes(project.durationDay3Ms);

                // Apply visibility to individual cells based on overallDay3Visibility
                // Use a class to hide cells.
                if (!overallDay3Visibility) { 
                    d3sCell.classList.add('hide-day3-column');
                    d3fCell.classList.add('hide-day3-column');
                    d3DurCell.classList.add('hide-day3-column');
                } else {
                    d3sCell.classList.remove('hide-day3-column'); 
                    d3fCell.classList.remove('hide-day3-column');
                    d3DurCell.classList.remove('hide-day3-column');
                }
                // END NEW

                let totalRawDurationMs = (project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) + (project.durationDay3Ms || 0); // NEW: Include Day 3
                let breakInMs = (project.breakDurationMinutes || 0) * 60 * 1000; 

                let finalTotalDurationMs = totalRawDurationMs > 0 ? Math.max(0, totalRawDurationMs - breakInMs) : null;
                
                const totalDurationCell = row.insertCell();
                totalDurationCell.textContent = formatMillisToMinutes(finalTotalDurationMs);
                totalDurationCell.classList.add('total-duration-column');

                row.insertCell().textContent = project.breakDurationMinutes || 0;

                const techNotesCell = row.insertCell(); 
                const techNotesInput = document.createElement('textarea'); 
                techNotesInput.value = project.techNotes || ''; 
                techNotesInput.placeholder = 'Notes'; 
                techNotesInput.classList.add('tech-notes-input'); 
                techNotesInput.rows = 1; 
                techNotesInput.id = `techNotes_${project.id}`; 
                techNotesInput.disabled = project.status === 'Reassigned_TechAbsent'; 
                techNotesInput.onchange = async (event) => { 
                    const newVal = event.target.value; 
                    if (!db || !project.id) { alert("Error: Cannot save. DB or ID missing."); event.target.value = project.techNotes || ''; return; } 
                    try { 
                        await db.collection("projects").doc(project.id).update({ techNotes: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() }); 
                    } catch (error) { 
                        console.error("Error updating techNotes:", error); 
                        alert("Error saving Tech Notes. Error: " + error.message); 
                        event.target.value = project.techNotes || ''; 
                    } 
                }; 
                techNotesCell.appendChild(techNotesInput); 
                
                const actionsCell = row.insertCell(); 
                const btnContainer = document.createElement('div'); 
                
                const breakSelect = document.createElement('select');
                breakSelect.classList.add('break-select');
                breakSelect.id = `breakSelect_${project.id}`;

                let defaultOption = document.createElement('option');
                defaultOption.value = '0';
                defaultOption.textContent = 'No Break';
                breakSelect.appendChild(defaultOption);

                let option15Min = document.createElement('option');
                option15Min.value = '15'; 
                option15Min.textContent = '15 mins Break';
                breakSelect.appendChild(option15Min);

                let option60Min = document.createElement('option');
                option60Min.value = '60'; 
                option60Min.textContent = '1 hr Break';
                breakSelect.appendChild(option60Min);

                let option90Min = document.createElement('option');
                option90Min.value = '90'; 
                option90Min.textContent = '1 hr 30 mins Break';
                breakSelect.appendChild(option90Min);

                if (typeof project.breakDurationMinutes === 'number') {
                    breakSelect.value = project.breakDurationMinutes.toString();
                } else {
                    breakSelect.value = '0'; 
                }

                breakSelect.onchange = async (event) => {
                    const selectedBreakMinutes = parseInt(event.target.value, 10);
                    if (!db || !project.id) {
                        alert("Error: Cannot save break. DB or ID missing.");
                        event.target.value = project.breakDurationMinutes ? project.breakDurationMinutes.toString() : '0';
                        return;
                    }
                    try {
                        await db.collection("projects").doc(project.id).update({
                            breakDurationMinutes: selectedBreakMinutes,
                            lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`Updated break for ${project.id} to ${selectedBreakMinutes} minutes.`);
                    } catch (error) {
                        console.error("Error updating break duration:", error);
                        alert("Error saving Break Duration. Error: " + error.message);
                        event.target.value = project.breakDurationMinutes ? project.breakDurationMinutes.toString() : '0';
                    }
                };
                btnContainer.appendChild(breakSelect); 


                const isOriginalReassignedTask = project.status === 'Reassigned_TechAbsent'; 
                const sD1btn = document.createElement('button'); sD1btn.textContent = 'Start D1'; sD1btn.classList.add('btn','btn-day-start'); sD1btn.disabled = project.status !== 'Available' || isOriginalReassignedTask; sD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay1'); }; btnContainer.appendChild(sD1btn); 
                const eD1btn = document.createElement('button'); eD1btn.textContent = 'End D1'; eD1btn.classList.add('btn','btn-day-end'); eD1btn.disabled = project.status !== 'InProgressDay1' || isOriginalReassignedTask; eD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay1'); }; btnContainer.appendChild(eD1btn); 
                const sD2btn = document.createElement('button'); sD2btn.textContent = 'Start D2'; sD2btn.classList.add('btn','btn-day-start'); sD2btn.disabled = project.status !== 'Day1Ended_AwaitingNext' || isOriginalReassignedTask; sD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay2'); }; btnContainer.appendChild(sD2btn); 
                const eD2btn = document.createElement('button'); eD2btn.textContent = 'End D2'; eD2btn.classList.add('btn','btn-day-end'); eD2btn.disabled = project.status !== 'InProgressDay2' || isOriginalReassignedTask; eD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay2'); }; btnContainer.appendChild(eD2btn); 
                
                // NEW: Day 3 Buttons
                const sD3btn = document.createElement('button'); 
                sD3btn.textContent = 'Start D3'; 
                sD3btn.classList.add('btn','btn-day-start'); 
                // Enable if Day 2 is ended or Day 1 ended and Day 2 was skipped
                sD3btn.disabled = !((project.status === 'Completed' && project.durationDay2Ms !== null) || // Completed Day 2
                                    (project.status === 'Day1Ended_AwaitingNext' && project.durationDay1Ms !== null) || // Day 1 ended, no Day 2
                                    (project.status === 'InProgressDay2' && project.durationDay2Ms === null)) || // Currently in Day 2, allow to mark D2 done and then start D3
                                    isOriginalReassignedTask || project.startTimeDay3 !== null; 

                sD3btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay3'); }; 
                btnContainer.appendChild(sD3btn); 
                
                const eD3btn = document.createElement('button'); 
                eD3btn.textContent = 'End D3'; 
                eD3btn.classList.add('btn','btn-day-end'); 
                eD3btn.disabled = project.startTimeDay3 === null || isOriginalReassignedTask || project.finishTimeDay3 !== null; 
                eD3btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay3'); }; 
                btnContainer.appendChild(eD3btn); 
                // END NEW

                const doneBtn = document.createElement('button'); doneBtn.textContent = 'Done'; doneBtn.classList.add('btn','btn-mark-done'); doneBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; doneBtn.onclick = () => { if (project.id) updateProjectState(project.id, 'markDone'); }; btnContainer.appendChild(doneBtn); 
                const reassignBtn = document.createElement('button'); reassignBtn.textContent = 'Re-Assign'; reassignBtn.classList.add('btn', 'btn-warning'); reassignBtn.title = 'Re-assign task by creating a new entry.'; reassignBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; reassignBtn.onclick = () => { const currentProjectData = projects.find(p => p.id === project.id); if (currentProjectData) handleReassignment(currentProjectData); else alert("Error: Could not retrieve task data for re-assignment."); }; btnContainer.appendChild(reassignBtn); 
                actionsCell.appendChild(btnContainer); 
            });
        }

        async function updateProjectState(projectId, action) { 
            if (!db) { alert("Database not initialized!"); return; } 
            if (!projectId) { alert("Error: Project ID missing."); return; } 
            
            const projectRef = db.collection("projects").doc(projectId); 
            let currentProjectData; 
            try { 
                const doc = await projectRef.get(); 
                if (!doc.exists) { alert(`Error: Project ${projectId} not found.`); return; } 
                currentProjectData = doc.data(); 
            } catch(error) { console.error("Error fetching project:", error); alert("Error fetching project. Error: " + error.message); return; } 
            
            if (!currentProjectData) { alert(`Error: Could not get data for project ${projectId}.`); return; } 
            if (currentProjectData.status === 'Reassigned_TechAbsent') { alert("This task instance was re-assigned and is closed. No further status changes allowed on this instance."); return; } 
            
            const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp(); 
            const clientNowMillis = Date.now(); 
            let updatedFields = { lastModifiedTimestamp: serverTimestamp }; 
            
            switch (action) { 
                case 'startDay1': 
                    if (currentProjectData.status === 'Available') updatedFields = { ...updatedFields, status: 'InProgressDay1', startTimeDay1: serverTimestamp, finishTimeDay1: null, durationDay1Ms: null, startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null, startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null }; // NEW: Reset Day 3 fields
                    else console.warn(`Cannot 'startDay1'. Status: ${currentProjectData.status}`); 
                    break; 
                case 'endDay1': 
                    if (currentProjectData.status === 'InProgressDay1' && currentProjectData.startTimeDay1) updatedFields = { ...updatedFields, status: 'Day1Ended_AwaitingNext', finishTimeDay1: serverTimestamp, durationDay1Ms: calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis) }; 
                    else console.warn(`Cannot 'endDay1'. Status: ${currentProjectData.status}`); 
                    break; 
                case 'startDay2': 
                    if (currentProjectData.status === 'Day1Ended_AwaitingNext') updatedFields = { ...updatedFields, status: 'InProgressDay2', startTimeDay2: serverTimestamp, finishTimeDay2: null, durationDay2Ms: null, startTimeDay3: null, finishTimeDay3: null, durationDay3Ms: null }; // NEW: Reset Day 3 fields
                    else console.warn(`Cannot 'startDay2'. Status: ${currentProjectData.status}`); 
                    break; 
                case 'endDay2': 
                    if (currentProjectData.status === 'InProgressDay2' && currentProjectData.startTimeDay2) updatedFields = { ...updatedFields, status: 'Completed', finishTimeDay2: serverTimestamp, durationDay2Ms: calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis) }; 
                    else console.warn(`Cannot 'endDay2'. Status: ${currentProjectData.status}`); 
                    break; 
                // NEW: Day 3 Cases
                case 'startDay3':
                    // To start Day 3, Day 1 and optionally Day 2 should be completed.
                    // If status is InProgressDay2, we assume they implicitly end Day2 then start Day3
                    if (currentProjectData.status === 'Completed' || currentProjectData.status === 'Day1Ended_AwaitingNext' || currentProjectData.status === 'InProgressDay2') {
                        // If coming from InProgressDay2, ensure Day 2 is marked complete
                        if (currentProjectData.status === 'InProgressDay2' && !currentProjectData.finishTimeDay2) {
                            updatedFields.finishTimeDay2 = serverTimestamp;
                            updatedFields.durationDay2Ms = calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis);
                        }
                        // If coming from Day1Ended, and Day2 was skipped (no startTimeDay2), mark Day2 as null explicitly
                        if (currentProjectData.status === 'Day1Ended_AwaitingNext' && !currentProjectData.startTimeDay2) {
                            updatedFields.startTimeDay2 = null;
                            updatedFields.finishTimeDay2 = null;
                            updatedFields.durationDay2Ms = null;
                        }
                        updatedFields = { ...updatedFields, status: 'InProgressDay3', startTimeDay3: serverTimestamp, finishTimeDay3: null, durationDay3Ms: null };
                    } else console.warn(`Cannot 'startDay3'. Status: ${currentProjectData.status}`);
                    break;
                case 'endDay3':
                    if (currentProjectData.status === 'InProgressDay3' && currentProjectData.startTimeDay3) updatedFields = { ...updatedFields, status: 'Completed', finishTimeDay3: serverTimestamp, durationDay3Ms: calculateDurationMs(currentProjectData.startTimeDay3, clientNowMillis) };
                    else console.warn(`Cannot 'endDay3'. Status: ${currentProjectData.status}`);
                    break;
                // END NEW
                case 'markDone': 
                    if (currentProjectData.status !== 'Completed') { 
                        updatedFields.status = 'Completed'; 
                        if (currentProjectData.startTimeDay1 && !currentProjectData.finishTimeDay1) { 
                            updatedFields.finishTimeDay1 = serverTimestamp; 
                            updatedFields.durationDay1Ms = calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis); 
                        } 
                        if (currentProjectData.startTimeDay2 && !currentProjectData.finishTimeDay2) { 
                            updatedFields.finishTimeDay2 = serverTimestamp; 
                            updatedFields.durationDay2Ms = calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis); 
                        } 
                        if (!currentProjectData.startTimeDay2) { 
                            updatedFields.durationDay2Ms = null; 
                            updatedFields.finishTimeDay2 = null; 
                        } 
                        // NEW: Mark Day 3 Done
                        if (currentProjectData.startTimeDay3 && !currentProjectData.finishTimeDay3) { 
                            updatedFields.finishTimeDay3 = serverTimestamp; 
                            updatedFields.durationDay3Ms = calculateDurationMs(currentProjectData.startTimeDay3, clientNowMillis); 
                        } 
                        if (!currentProjectData.startTimeDay3) { 
                            updatedFields.durationDay3Ms = null; 
                            updatedFields.finishTimeDay3 = null; 
                        } 
                        // END NEW
                    } else console.warn(`Cannot 'markDone'. Status: ${currentProjectData.status}`); 
                    break; 
                default: 
                    console.log("Unknown action:", action); return; 
            } 
            
            if (Object.keys(updatedFields).length > 1) { 
                try { 
                    await projectRef.update(updatedFields); 
                    console.log(`Project ${projectId} action ${action} updated.`); 
                } catch (error) { 
                    console.error(`Error updating project ${projectId}:`, error); 
                    alert(`Error updating project. Error: ${error.message}`); 
                } 
            } else console.log(`No fields to update for ${action} on ${projectId}. Status: ${currentProjectData.status}`);
        }

        async function handleReassignment(originalProjectData) { 
            if (!originalProjectData || !originalProjectData.id) { alert("Cannot re-assign: Original task data is missing."); return; } 
            if (originalProjectData.status === 'Reassigned_TechAbsent') { alert("This task instance has already been re-assigned. You can re-assign the newly created active task if needed."); return; } 
            if (originalProjectData.status === 'Completed') { alert("Cannot re-assign a completed task."); return; } 
            
            const currentTechId = originalProjectData.assignedTo || "N/A"; 
            const newTechId = prompt(`Task for '${originalProjectData.areaTask}' is currently assigned to '${currentTechId}'.\nEnter New Technician ID for the NEW re-assigned task entry:`); 
            if (newTechId === null) { console.log("Re-assignment cancelled."); return; } 
            
            const trimmedNewTechId = newTechId.trim(); 
            if (trimmedNewTechId === "") { alert("New Technician ID cannot be empty."); return; } 
            
            const confirmation = confirm( 
                `Create a NEW task entry for '${trimmedNewTechId}' based on Area/Task '${originalProjectData.areaTask}' (from '${currentTechId}')?\n\n` + 
                `The current task row for '${currentTechId}' will be marked 'Re-Assigned' and closed.\n` + 
                `The new task row will have a distinct highlight and fresh time tracking.` 
            ); 
            
            if (confirmation) { 
                if (!db) { alert("CRITICAL: Database not initialized!"); return; } 
                const batch = db.batch(); 
                const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp(); 
                
                const newProjectEntryData = { 
                    batchId: originalProjectData.batchId, 
                    baseProjectName: originalProjectData.baseProjectName, 
                    areaTask: originalProjectData.areaTask, 
                    gsd: originalProjectData.gsd, 
                    fixCategory: originalProjectData.fixCategory, 
                    assignedTo: trimmedNewTechId, 
                    status: 'Available', 
                    startTimeDay1: null, 
                    finishTimeDay1: null, 
                    durationDay1Ms: null, 
                    startTimeDay2: null, 
                    finishTimeDay2: null, 
                    durationDay2Ms: null, 
                    // NEW: Day 3 fields for re-assigned task
                    startTimeDay3: null, 
                    finishTimeDay3: null, 
                    durationDay3Ms: null, 
                    // END NEW
                    techNotes: ``, 
                    creationTimestamp: serverTimestamp, 
                    lastModifiedTimestamp: serverTimestamp, 
                    isReassigned: true, 
                    originalProjectId: originalProjectData.id, 
                    releasedToNextStage: false,
                    breakDurationMinutes: 0 
                }; 
                const newProjectRef = db.collection("projects").doc(); 
                batch.set(newProjectRef, newProjectEntryData); 
                
                const originalProjectRef = db.collection("projects").doc(originalProjectData.id); 
                const originalTaskUpdateData = { 
                    status: 'Reassigned_TechAbsent', 
                    techNotes: (originalProjectData.techNotes || "") + `\n--- THIS TASK INSTANCE WAS RE-ASSIGNED to '${trimmedNewTechId}' on ${new Date().toLocaleString()}. This instance is now closed. New task ID: ${newProjectRef.id} ---`, 
                    lastModifiedTimestamp: serverTimestamp 
                }; 
                batch.update(originalProjectRef, originalTaskUpdateData); 
                
                try { 
                    await batch.commit(); 
                    console.log(`Task ${originalProjectData.id} marked re-assigned. New task ${newProjectRef.id} created for ${trimmedNewTechId}.`); 
                } catch (error) { 
                    console.error(`Error in batch re-assignment for ${originalProjectData.id}:`, error); 
                    alert(`Error re-assigning task. Error: ${error.message}`); 
                } 
            }
        }

        function refreshAllViews() { 
            try { 
                renderProjects(); 
                if (tlDashboardModal && tlDashboardModal.style.display === 'block') renderTLDashboard(); 
                if (settingsModal && settingsModal.style.display === 'block') renderAllowedEmailsList(); 
            } catch (e) { 
                console.error("Error during refreshAllViews:", e); 
                alert("Error refreshing view. Error: " + e.message); 
            }
        }
        
        async function renderAllowedEmailsList() {
            if (!allowedEmailsList) { console.error("allowedEmailsList element not found."); return; }
            await fetchAllowedEmails(); 
            allowedEmailsList.innerHTML = '';
            if (allowedEmailsFromFirestore.length === 0) {
                allowedEmailsList.innerHTML = '<li>No allowed emails configured.</li>';
                return;
            }

            allowedEmailsFromFirestore.forEach(email => {
                const li = document.createElement('li');
                li.textContent = email;
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => handleRemoveEmail(email);
                li.appendChild(removeBtn);
                allowedEmailsList.appendChild(li);
            });
        }

        async function handleAddEmail() {
            if (!addEmailInput) { console.error("addEmailInput element not found."); return; }
            const newEmail = addEmailInput.value.trim().toLowerCase();
            if (!newEmail || !newEmail.includes('@')) {
                alert("Please enter a valid email address.");
                return;
            }

            if (allowedEmailsFromFirestore.includes(newEmail)) {
                alert("This email is already in the allowed list.");
                return;
            }

            const updatedEmails = [...allowedEmailsFromFirestore, newEmail].sort();
            const success = await updateAllowedEmailsInFirestore(updatedEmails);
            if (success) {
                addEmailInput.value = ''; 
                renderAllowedEmailsList(); 
            }
        }

        async function handleRemoveEmail(emailToRemove) {
            if (confirm(`Are you sure you want to remove ${emailToRemove} from the allowed list?`)) {
                const updatedEmails = allowedEmailsFromFirestore.filter(email => email !== emailToRemove);
                const success = await updateAllowedEmailsInFirestore(updatedEmails);
                if (success) {
                    renderAllowedEmailsList(); 
                }
            }
        }

        function setupAuthRelatedDOMReferences() {
            signInBtn = document.getElementById('signInBtn');
            signOutBtn = document.getElementById('signOutBtn');
            userInfoDisplayDiv = document.getElementById('user-info-display');
            userNameP = document.getElementById('userName');
            userEmailP = document.getElementById('userEmail');
            userPhotoImg = document.getElementById('userPhoto');
            appContentDiv = document.getElementById('app-content');
            loadingAuthMessageDiv = document.getElementById('loading-auth-message');
            openSettingsBtn = document.getElementById('openSettingsBtn'); 
        }

        function setupAuthEventListeners() {
            const provider = new firebase.auth.GoogleAuthProvider();

            if (signInBtn) { 
                signInBtn.addEventListener('click', () => {
                    if (!auth) { console.error("Auth not initialized"); return; }
                    auth.signInWithPopup(provider)
                        .then((result) => {
                            console.log("Sign-in attempt successful for: ", result.user.email);
                        })
                        .catch((error) => {
                            console.error("Sign-in error: ", error);
                            let errorMessage = "Error signing in: " + error.message;
                            if (error.code === 'auth/popup-closed-by-user') {
                                errorMessage = "Sign-in process was cancelled. Please try again.";
                            } else if (error.code === 'auth/cancelled-popup-request') {
                                errorMessage = "Sign-in process was interrupted. Please try again.";
                            } else if (error.code === 'auth/popup-blocked') {
                                errorMessage = "Sign-in pop-up was blocked by the browser. Please allow pop-ups for this site and try again.";
                            }
                            alert(errorMessage);
                            if (loadingAuthMessageDiv && signInBtn && userInfoDisplayDiv && appContentDiv) { 
                                userInfoDisplayDiv.style.display = 'none';
                                signInBtn.style.display = 'block';
                                appContentDiv.style.display = 'none';
                                loadingAuthMessageDiv.innerHTML = '<p>Please sign in to access the Project Tracker.</p>';
                                loadingAuthMessageDiv.style.display = 'block';
                            }
                        });
                });
            } else {
                console.error("Sign-in button not found during event listener setup.");
            }

            if (signOutBtn) { 
                signOutBtn.addEventListener('click', () => {
                    if (!auth) { console.error("Auth not initialized"); return; }
                    auth.signOut()
                        .then(() => {
                            console.log("User signed out successfully by clicking button.");
                        })
                        .catch((error) => {
                            console.error("Sign-out error: ", error);
                            alert("Error signing out: " + error.message);
                        });
                });
            } else {
                console.error("Sign-out button not found during event listener setup.");
            }
        }

        function initializeAppComponents() {
            if (!isAppInitialized) {
                console.log("Initializing app components (DOM refs, event listeners, Firestore data)...");
                setupDOMReferences(); 
                attachEventListeners(); 
                initializeFirebaseAndLoadData(); 
                isAppInitialized = true;
            } else {
                console.log("App components already initialized or re-initializing data load.");
                initializeFirebaseAndLoadData(); 
            }
        }

        if (auth) { 
            auth.onAuthStateChanged(async (user) => { 
                if (!userNameP || !userEmailP || !userPhotoImg || !userInfoDisplayDiv || !signInBtn || !appContentDiv || !loadingAuthMessageDiv || !openSettingsBtn) {
                    console.error("One or more critical UI elements for auth state change not found. Attempting to re-acquire.");
                    setupAuthRelatedDOMReferences(); 
                    if (!userNameP || !userEmailP || !userPhotoImg || !userInfoDisplayDiv || !signInBtn || !appContentDiv || !loadingAuthMessageDiv || !openSettingsBtn) {
                        console.error("Still unable to find critical UI elements. Aborting UI update for auth state change.");
                        return; 
                    }
                }

                if (user) {
                    await fetchAllowedEmails(); 
                    const userEmailLower = user.email ? user.email.toLowerCase() : ""; 
                    if (user.email && allowedEmailsFromFirestore.map(email => email.toLowerCase()).includes(userEmailLower)) {
                        console.log("Auth state changed: User is SIGNED IN and ALLOWED - ", user.displayName, user.email);
                        userNameP.textContent = user.displayName || "Name not available";
                        userEmailP.textContent = user.email || "Email not available";
                        userPhotoImg.src = user.photoURL || "default-user.png"; 

                        userInfoDisplayDiv.style.display = 'flex';
                        signInBtn.style.display = 'none';
                        loadingAuthMessageDiv.style.display = 'none'; 
                        appContentDiv.style.display = 'block'; 
                        openSettingsBtn.style.display = 'block'; 

                        initializeAppComponents();
                    } else {
                        console.warn("Auth state changed: User SIGNED IN but NOT ALLOWED - ", user.email);
                        alert("Access Denied: Your email address (" + (user.email || "N/A") + ") is not authorized to use this application.");
                        
                        auth.signOut().then(() => {
                            console.log("Unauthorized user automatically signed out.");
                            loadingAuthMessageDiv.innerHTML = '<p>Access Denied. Please sign in with an authorized account.</p>';
                            userNameP.textContent = '';
                            userEmailP.textContent = '';
                            userPhotoImg.src = '';
                            userInfoDisplayDiv.style.display = 'none';
                            signInBtn.style.display = 'block';
                            appContentDiv.style.display = 'none';
                            loadingAuthMessageDiv.style.display = 'block';
                            openSettingsBtn.style.display = 'none'; 

                            projects = [];
                            if (projectTableBody) projectTableBody.innerHTML = ''; 
                            if (tlDashboardContentElement) tlDashboardContentElement.innerHTML = '';
                            if (firestoreListenerUnsubscribe) {
                                firestoreListenerUnsubscribe();
                                firestoreListenerUnsubscribe = null;
                                console.log("Firestore listener detached for unauthorized user sign out.");
                            }
                            isAppInitialized = false; 
                        }).catch(error => {
                            console.error("Error signing out unauthorized user:", error);
                            userNameP.textContent = '';
                            userEmailP.textContent = '';
                            userPhotoImg.src = '';
                            userInfoDisplayDiv.style.display = 'none';
                            signInBtn.style.display = 'block';
                            appContentDiv.style.display = 'none';
                            loadingAuthMessageDiv.innerHTML = '<p>Access Denied. Error during sign out. Please refresh.</p>';
                            loadingAuthMessageDiv.style.display = 'block';
                            openSettingsBtn.style.display = 'none'; 
                        });
                    }

                } else {
                    console.log("Auth state changed: User is SIGNED OUT");
                    userNameP.textContent = ''; 
                    userEmailP.textContent = '';
                    userPhotoImg.src = '';

                    userInfoDisplayDiv.style.display = 'none';
                    signInBtn.style.display = 'block';
                    appContentDiv.style.display = 'none'; 
                    openSettingsBtn.style.display = 'none'; 
                    
                    if (loadingAuthMessageDiv.textContent.indexOf("Access Denied") === -1) {
                         loadingAuthMessageDiv.innerHTML = '<p>Please sign in to access the Project Tracker.</p>';
                    }
                    loadingAuthMessageDiv.style.display = 'block'; 
                    
                    projects = [];
                    if (projectTableBody) projectTableBody.innerHTML = ''; 
                    if (tlDashboardContentElement) tlDashboardContentElement.innerHTML = '';
                    if (allowedEmailsList) allowedEmailsList.innerHTML = ''; 
                    
                    if (firestoreListenerUnsubscribe) {
                        firestoreListenerUnsubscribe();
                        firestoreListenerUnsubscribe = null; 
                        console.log("Firestore listener detached on sign out.");
                    }
                    isAppInitialized = false; 
                    console.log("App content hidden, project data cleared, and Firestore listener detached.");
                }
            });
        } else {
            console.error("Firebase Auth is not initialized. UI updates based on auth state will not occur.");
             const loadingMsgDiv = document.getElementById('loading-auth-message');
            if (loadingMsgDiv) loadingMsgDiv.innerHTML = `<p style="color:red; font-weight:bold;">Authentication services could not be loaded. Please check the console and refresh.</p>`;
        }


        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");
            setupAuthRelatedDOMReferences(); 

            if (auth) { 
                setupAuthEventListeners(); 
                console.log("Auth UI and event listeners set up.");
            } else {
                console.error("Firebase Auth not available on DOMContentLoaded. Auth UI setup skipped.");
                const authContainer = document.getElementById('auth-container');
                if (authContainer) {
                    const errorDiv = document.createElement('div');
                    errorDiv.innerHTML = '<p style="color:red; font-weight:bold;">Authentication services could not be loaded. Please check the console and refresh.</p>';
                    authContainer.prepend(errorDiv);
                }
            }
        });
    </script>
</body>
</html>
